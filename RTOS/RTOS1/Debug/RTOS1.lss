
RTOS1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002750  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00002750  000027e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f7  0080006e  0080006e  000027f2  2**0
                  ALLOC
  3 .stab         000043c8  00000000  00000000  000027f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000293f  00000000  00000000  00006bbc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 18 08 	jmp	0x1030	; 0x1030 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e5       	ldi	r30, 0x50	; 80
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 36       	cpi	r26, 0x65	; 101
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 a6 13 	jmp	0x274c	; 0x274c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	cd b7       	in	r28, 0x3d	; 61
      a6:	de b7       	in	r29, 0x3e	; 62
      a8:	20 e6       	ldi	r18, 0x60	; 96
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	86 e8       	ldi	r24, 0x86	; 134
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	b9 01       	movw	r22, r18
      b2:	40 e5       	ldi	r20, 0x50	; 80
      b4:	50 e0       	ldi	r21, 0x00	; 0
      b6:	20 e0       	ldi	r18, 0x00	; 0
      b8:	30 e0       	ldi	r19, 0x00	; 0
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	ee 24       	eor	r14, r14
      be:	ff 24       	eor	r15, r15
      c0:	cc 24       	eor	r12, r12
      c2:	dd 24       	eor	r13, r13
      c4:	aa 24       	eor	r10, r10
      c6:	bb 24       	eor	r11, r11
      c8:	0e 94 9c 0c 	call	0x1938	; 0x1938 <xTaskGenericCreate>
      cc:	20 e6       	ldi	r18, 0x60	; 96
      ce:	30 e0       	ldi	r19, 0x00	; 0
      d0:	88 ea       	ldi	r24, 0xA8	; 168
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	b9 01       	movw	r22, r18
      d6:	40 e5       	ldi	r20, 0x50	; 80
      d8:	50 e0       	ldi	r21, 0x00	; 0
      da:	20 e0       	ldi	r18, 0x00	; 0
      dc:	30 e0       	ldi	r19, 0x00	; 0
      de:	01 e0       	ldi	r16, 0x01	; 1
      e0:	ee 24       	eor	r14, r14
      e2:	ff 24       	eor	r15, r15
      e4:	cc 24       	eor	r12, r12
      e6:	dd 24       	eor	r13, r13
      e8:	aa 24       	eor	r10, r10
      ea:	bb 24       	eor	r11, r11
      ec:	0e 94 9c 0c 	call	0x1938	; 0x1938 <xTaskGenericCreate>
      f0:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <vTaskStartScheduler>
      f4:	80 e0       	ldi	r24, 0x00	; 0
      f6:	90 e0       	ldi	r25, 0x00	; 0
      f8:	cf 91       	pop	r28
      fa:	df 91       	pop	r29
      fc:	0f 91       	pop	r16
      fe:	ff 90       	pop	r15
     100:	ef 90       	pop	r14
     102:	df 90       	pop	r13
     104:	cf 90       	pop	r12
     106:	bf 90       	pop	r11
     108:	af 90       	pop	r10
     10a:	08 95       	ret

0000010c <task1_code>:
    
}

/*Task1 Code */
 void task1_code(void*pvParamter)
{
     10c:	df 93       	push	r29
     10e:	cf 93       	push	r28
     110:	00 d0       	rcall	.+0      	; 0x112 <task1_code+0x6>
     112:	00 d0       	rcall	.+0      	; 0x114 <task1_code+0x8>
     114:	cd b7       	in	r28, 0x3d	; 61
     116:	de b7       	in	r29, 0x3e	; 62
     118:	9c 83       	std	Y+4, r25	; 0x04
     11a:	8b 83       	std	Y+3, r24	; 0x03
	 SET_BIT(DDRD,7);
     11c:	a1 e3       	ldi	r26, 0x31	; 49
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	e1 e3       	ldi	r30, 0x31	; 49
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	80 68       	ori	r24, 0x80	; 128
     128:	8c 93       	st	X, r24

	 portTickType x;
	 x=xTaskGetTickCount();
     12a:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <xTaskGetTickCount>
     12e:	9a 83       	std	Y+2, r25	; 0x02
     130:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		TOGGLE_BIT(PORTD,7);
     132:	a2 e3       	ldi	r26, 0x32	; 50
     134:	b0 e0       	ldi	r27, 0x00	; 0
     136:	e2 e3       	ldi	r30, 0x32	; 50
     138:	f0 e0       	ldi	r31, 0x00	; 0
     13a:	90 81       	ld	r25, Z
     13c:	80 e8       	ldi	r24, 0x80	; 128
     13e:	89 27       	eor	r24, r25
     140:	8c 93       	st	X, r24
		vTaskDelayUntil(&x,200);
     142:	ce 01       	movw	r24, r28
     144:	01 96       	adiw	r24, 0x01	; 1
     146:	68 ec       	ldi	r22, 0xC8	; 200
     148:	70 e0       	ldi	r23, 0x00	; 0
     14a:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <vTaskDelayUntil>
     14e:	f1 cf       	rjmp	.-30     	; 0x132 <task1_code+0x26>

00000150 <task2_code>:
		
}

/*Task 2 Code*/
 void task2_code(void*pvParamter)
{
     150:	df 93       	push	r29
     152:	cf 93       	push	r28
     154:	00 d0       	rcall	.+0      	; 0x156 <task2_code+0x6>
     156:	00 d0       	rcall	.+0      	; 0x158 <task2_code+0x8>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9c 83       	std	Y+4, r25	; 0x04
     15e:	8b 83       	std	Y+3, r24	; 0x03
	 SET_BIT(DDRD,6);
     160:	a1 e3       	ldi	r26, 0x31	; 49
     162:	b0 e0       	ldi	r27, 0x00	; 0
     164:	e1 e3       	ldi	r30, 0x31	; 49
     166:	f0 e0       	ldi	r31, 0x00	; 0
     168:	80 81       	ld	r24, Z
     16a:	80 64       	ori	r24, 0x40	; 64
     16c:	8c 93       	st	X, r24

	 portTickType x;
	 x=xTaskGetTickCount();
     16e:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <xTaskGetTickCount>
     172:	9a 83       	std	Y+2, r25	; 0x02
     174:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		TOGGLE_BIT(PORTD,6);
     176:	a2 e3       	ldi	r26, 0x32	; 50
     178:	b0 e0       	ldi	r27, 0x00	; 0
     17a:	e2 e3       	ldi	r30, 0x32	; 50
     17c:	f0 e0       	ldi	r31, 0x00	; 0
     17e:	90 81       	ld	r25, Z
     180:	80 e4       	ldi	r24, 0x40	; 64
     182:	89 27       	eor	r24, r25
     184:	8c 93       	st	X, r24
		vTaskDelayUntil(&x,1000);
     186:	ce 01       	movw	r24, r28
     188:	01 96       	adiw	r24, 0x01	; 1
     18a:	68 ee       	ldi	r22, 0xE8	; 232
     18c:	73 e0       	ldi	r23, 0x03	; 3
     18e:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <vTaskDelayUntil>
     192:	f1 cf       	rjmp	.-30     	; 0x176 <task2_code+0x26>

00000194 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     194:	df 93       	push	r29
     196:	cf 93       	push	r28
     198:	cd b7       	in	r28, 0x3d	; 61
     19a:	de b7       	in	r29, 0x3e	; 62
     19c:	27 97       	sbiw	r28, 0x07	; 7
     19e:	0f b6       	in	r0, 0x3f	; 63
     1a0:	f8 94       	cli
     1a2:	de bf       	out	0x3e, r29	; 62
     1a4:	0f be       	out	0x3f, r0	; 63
     1a6:	cd bf       	out	0x3d, r28	; 61
     1a8:	9d 83       	std	Y+5, r25	; 0x05
     1aa:	8c 83       	std	Y+4, r24	; 0x04
     1ac:	6e 83       	std	Y+6, r22	; 0x06
     1ae:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     1b0:	8a e1       	ldi	r24, 0x1A	; 26
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	0e 94 a2 03 	call	0x744	; 0x744 <pvPortMalloc>
     1b8:	9a 83       	std	Y+2, r25	; 0x02
     1ba:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     1bc:	89 81       	ldd	r24, Y+1	; 0x01
     1be:	9a 81       	ldd	r25, Y+2	; 0x02
     1c0:	00 97       	sbiw	r24, 0x00	; 0
     1c2:	09 f4       	brne	.+2      	; 0x1c6 <xCoRoutineCreate+0x32>
     1c4:	6f c0       	rjmp	.+222    	; 0x2a4 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     1c6:	80 91 6e 00 	lds	r24, 0x006E
     1ca:	90 91 6f 00 	lds	r25, 0x006F
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f4       	brne	.+16     	; 0x1e2 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	9a 81       	ldd	r25, Y+2	; 0x02
     1d6:	90 93 6f 00 	sts	0x006F, r25
     1da:	80 93 6e 00 	sts	0x006E, r24
			prvInitialiseCoRoutineLists();
     1de:	0e 94 31 03 	call	0x662	; 0x662 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     1e2:	8e 81       	ldd	r24, Y+6	; 0x06
     1e4:	82 30       	cpi	r24, 0x02	; 2
     1e6:	10 f0       	brcs	.+4      	; 0x1ec <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     1e8:	81 e0       	ldi	r24, 0x01	; 1
     1ea:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1ec:	e9 81       	ldd	r30, Y+1	; 0x01
     1ee:	fa 81       	ldd	r31, Y+2	; 0x02
     1f0:	11 8e       	std	Z+25, r1	; 0x19
     1f2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1f4:	e9 81       	ldd	r30, Y+1	; 0x01
     1f6:	fa 81       	ldd	r31, Y+2	; 0x02
     1f8:	8e 81       	ldd	r24, Y+6	; 0x06
     1fa:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1fc:	e9 81       	ldd	r30, Y+1	; 0x01
     1fe:	fa 81       	ldd	r31, Y+2	; 0x02
     200:	8f 81       	ldd	r24, Y+7	; 0x07
     202:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     204:	e9 81       	ldd	r30, Y+1	; 0x01
     206:	fa 81       	ldd	r31, Y+2	; 0x02
     208:	8c 81       	ldd	r24, Y+4	; 0x04
     20a:	9d 81       	ldd	r25, Y+5	; 0x05
     20c:	91 83       	std	Z+1, r25	; 0x01
     20e:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     210:	89 81       	ldd	r24, Y+1	; 0x01
     212:	9a 81       	ldd	r25, Y+2	; 0x02
     214:	02 96       	adiw	r24, 0x02	; 2
     216:	0e 94 38 04 	call	0x870	; 0x870 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     21a:	89 81       	ldd	r24, Y+1	; 0x01
     21c:	9a 81       	ldd	r25, Y+2	; 0x02
     21e:	0c 96       	adiw	r24, 0x0c	; 12
     220:	0e 94 38 04 	call	0x870	; 0x870 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     224:	e9 81       	ldd	r30, Y+1	; 0x01
     226:	fa 81       	ldd	r31, Y+2	; 0x02
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	91 87       	std	Z+9, r25	; 0x09
     22e:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     230:	e9 81       	ldd	r30, Y+1	; 0x01
     232:	fa 81       	ldd	r31, Y+2	; 0x02
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	9a 81       	ldd	r25, Y+2	; 0x02
     238:	93 8b       	std	Z+19, r25	; 0x13
     23a:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     23c:	8e 81       	ldd	r24, Y+6	; 0x06
     23e:	28 2f       	mov	r18, r24
     240:	30 e0       	ldi	r19, 0x00	; 0
     242:	85 e0       	ldi	r24, 0x05	; 5
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	82 1b       	sub	r24, r18
     248:	93 0b       	sbc	r25, r19
     24a:	e9 81       	ldd	r30, Y+1	; 0x01
     24c:	fa 81       	ldd	r31, Y+2	; 0x02
     24e:	95 87       	std	Z+13, r25	; 0x0d
     250:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     252:	e9 81       	ldd	r30, Y+1	; 0x01
     254:	fa 81       	ldd	r31, Y+2	; 0x02
     256:	96 89       	ldd	r25, Z+22	; 0x16
     258:	80 91 70 00 	lds	r24, 0x0070
     25c:	89 17       	cp	r24, r25
     25e:	28 f4       	brcc	.+10     	; 0x26a <xCoRoutineCreate+0xd6>
     260:	e9 81       	ldd	r30, Y+1	; 0x01
     262:	fa 81       	ldd	r31, Y+2	; 0x02
     264:	86 89       	ldd	r24, Z+22	; 0x16
     266:	80 93 70 00 	sts	0x0070, r24
     26a:	e9 81       	ldd	r30, Y+1	; 0x01
     26c:	fa 81       	ldd	r31, Y+2	; 0x02
     26e:	86 89       	ldd	r24, Z+22	; 0x16
     270:	28 2f       	mov	r18, r24
     272:	30 e0       	ldi	r19, 0x00	; 0
     274:	c9 01       	movw	r24, r18
     276:	88 0f       	add	r24, r24
     278:	99 1f       	adc	r25, r25
     27a:	88 0f       	add	r24, r24
     27c:	99 1f       	adc	r25, r25
     27e:	88 0f       	add	r24, r24
     280:	99 1f       	adc	r25, r25
     282:	82 0f       	add	r24, r18
     284:	93 1f       	adc	r25, r19
     286:	ac 01       	movw	r20, r24
     288:	49 58       	subi	r20, 0x89	; 137
     28a:	5f 4f       	sbci	r21, 0xFF	; 255
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	9a 81       	ldd	r25, Y+2	; 0x02
     290:	9c 01       	movw	r18, r24
     292:	2e 5f       	subi	r18, 0xFE	; 254
     294:	3f 4f       	sbci	r19, 0xFF	; 255
     296:	ca 01       	movw	r24, r20
     298:	b9 01       	movw	r22, r18
     29a:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>

		xReturn = pdPASS;
     29e:	81 e0       	ldi	r24, 0x01	; 1
     2a0:	8b 83       	std	Y+3, r24	; 0x03
     2a2:	02 c0       	rjmp	.+4      	; 0x2a8 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     2a4:	8f ef       	ldi	r24, 0xFF	; 255
     2a6:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     2a8:	8b 81       	ldd	r24, Y+3	; 0x03
}
     2aa:	27 96       	adiw	r28, 0x07	; 7
     2ac:	0f b6       	in	r0, 0x3f	; 63
     2ae:	f8 94       	cli
     2b0:	de bf       	out	0x3e, r29	; 62
     2b2:	0f be       	out	0x3f, r0	; 63
     2b4:	cd bf       	out	0x3d, r28	; 61
     2b6:	cf 91       	pop	r28
     2b8:	df 91       	pop	r29
     2ba:	08 95       	ret

000002bc <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     2bc:	df 93       	push	r29
     2be:	cf 93       	push	r28
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <vCoRoutineAddToDelayedList+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <vCoRoutineAddToDelayedList+0x8>
     2c4:	00 d0       	rcall	.+0      	; 0x2c6 <vCoRoutineAddToDelayedList+0xa>
     2c6:	cd b7       	in	r28, 0x3d	; 61
     2c8:	de b7       	in	r29, 0x3e	; 62
     2ca:	9c 83       	std	Y+4, r25	; 0x04
     2cc:	8b 83       	std	Y+3, r24	; 0x03
     2ce:	7e 83       	std	Y+6, r23	; 0x06
     2d0:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     2d2:	20 91 71 00 	lds	r18, 0x0071
     2d6:	30 91 72 00 	lds	r19, 0x0072
     2da:	8b 81       	ldd	r24, Y+3	; 0x03
     2dc:	9c 81       	ldd	r25, Y+4	; 0x04
     2de:	82 0f       	add	r24, r18
     2e0:	93 1f       	adc	r25, r19
     2e2:	9a 83       	std	Y+2, r25	; 0x02
     2e4:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2e6:	80 91 6e 00 	lds	r24, 0x006E
     2ea:	90 91 6f 00 	lds	r25, 0x006F
     2ee:	02 96       	adiw	r24, 0x02	; 2
     2f0:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     2f4:	e0 91 6e 00 	lds	r30, 0x006E
     2f8:	f0 91 6f 00 	lds	r31, 0x006F
     2fc:	89 81       	ldd	r24, Y+1	; 0x01
     2fe:	9a 81       	ldd	r25, Y+2	; 0x02
     300:	93 83       	std	Z+3, r25	; 0x03
     302:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     304:	20 91 71 00 	lds	r18, 0x0071
     308:	30 91 72 00 	lds	r19, 0x0072
     30c:	89 81       	ldd	r24, Y+1	; 0x01
     30e:	9a 81       	ldd	r25, Y+2	; 0x02
     310:	82 17       	cp	r24, r18
     312:	93 07       	cpc	r25, r19
     314:	70 f4       	brcc	.+28     	; 0x332 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     316:	80 91 9d 00 	lds	r24, 0x009D
     31a:	90 91 9e 00 	lds	r25, 0x009E
     31e:	20 91 6e 00 	lds	r18, 0x006E
     322:	30 91 6f 00 	lds	r19, 0x006F
     326:	2e 5f       	subi	r18, 0xFE	; 254
     328:	3f 4f       	sbci	r19, 0xFF	; 255
     32a:	b9 01       	movw	r22, r18
     32c:	0e 94 94 04 	call	0x928	; 0x928 <vListInsert>
     330:	0d c0       	rjmp	.+26     	; 0x34c <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     332:	80 91 9b 00 	lds	r24, 0x009B
     336:	90 91 9c 00 	lds	r25, 0x009C
     33a:	20 91 6e 00 	lds	r18, 0x006E
     33e:	30 91 6f 00 	lds	r19, 0x006F
     342:	2e 5f       	subi	r18, 0xFE	; 254
     344:	3f 4f       	sbci	r19, 0xFF	; 255
     346:	b9 01       	movw	r22, r18
     348:	0e 94 94 04 	call	0x928	; 0x928 <vListInsert>
	}

	if( pxEventList )
     34c:	8d 81       	ldd	r24, Y+5	; 0x05
     34e:	9e 81       	ldd	r25, Y+6	; 0x06
     350:	00 97       	sbiw	r24, 0x00	; 0
     352:	61 f0       	breq	.+24     	; 0x36c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     354:	80 91 6e 00 	lds	r24, 0x006E
     358:	90 91 6f 00 	lds	r25, 0x006F
     35c:	9c 01       	movw	r18, r24
     35e:	24 5f       	subi	r18, 0xF4	; 244
     360:	3f 4f       	sbci	r19, 0xFF	; 255
     362:	8d 81       	ldd	r24, Y+5	; 0x05
     364:	9e 81       	ldd	r25, Y+6	; 0x06
     366:	b9 01       	movw	r22, r18
     368:	0e 94 94 04 	call	0x928	; 0x928 <vListInsert>
	}
}
     36c:	26 96       	adiw	r28, 0x06	; 6
     36e:	0f b6       	in	r0, 0x3f	; 63
     370:	f8 94       	cli
     372:	de bf       	out	0x3e, r29	; 62
     374:	0f be       	out	0x3f, r0	; 63
     376:	cd bf       	out	0x3d, r28	; 61
     378:	cf 91       	pop	r28
     37a:	df 91       	pop	r29
     37c:	08 95       	ret

0000037e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     37e:	df 93       	push	r29
     380:	cf 93       	push	r28
     382:	00 d0       	rcall	.+0      	; 0x384 <prvCheckPendingReadyList+0x6>
     384:	cd b7       	in	r28, 0x3d	; 61
     386:	de b7       	in	r29, 0x3e	; 62
     388:	3a c0       	rjmp	.+116    	; 0x3fe <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     38a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     38c:	e0 91 a4 00 	lds	r30, 0x00A4
     390:	f0 91 a5 00 	lds	r31, 0x00A5
     394:	86 81       	ldd	r24, Z+6	; 0x06
     396:	97 81       	ldd	r25, Z+7	; 0x07
     398:	9a 83       	std	Y+2, r25	; 0x02
     39a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     39c:	89 81       	ldd	r24, Y+1	; 0x01
     39e:	9a 81       	ldd	r25, Y+2	; 0x02
     3a0:	0c 96       	adiw	r24, 0x0c	; 12
     3a2:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     3a6:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     3a8:	89 81       	ldd	r24, Y+1	; 0x01
     3aa:	9a 81       	ldd	r25, Y+2	; 0x02
     3ac:	02 96       	adiw	r24, 0x02	; 2
     3ae:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     3b2:	e9 81       	ldd	r30, Y+1	; 0x01
     3b4:	fa 81       	ldd	r31, Y+2	; 0x02
     3b6:	96 89       	ldd	r25, Z+22	; 0x16
     3b8:	80 91 70 00 	lds	r24, 0x0070
     3bc:	89 17       	cp	r24, r25
     3be:	28 f4       	brcc	.+10     	; 0x3ca <prvCheckPendingReadyList+0x4c>
     3c0:	e9 81       	ldd	r30, Y+1	; 0x01
     3c2:	fa 81       	ldd	r31, Y+2	; 0x02
     3c4:	86 89       	ldd	r24, Z+22	; 0x16
     3c6:	80 93 70 00 	sts	0x0070, r24
     3ca:	e9 81       	ldd	r30, Y+1	; 0x01
     3cc:	fa 81       	ldd	r31, Y+2	; 0x02
     3ce:	86 89       	ldd	r24, Z+22	; 0x16
     3d0:	28 2f       	mov	r18, r24
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	c9 01       	movw	r24, r18
     3d6:	88 0f       	add	r24, r24
     3d8:	99 1f       	adc	r25, r25
     3da:	88 0f       	add	r24, r24
     3dc:	99 1f       	adc	r25, r25
     3de:	88 0f       	add	r24, r24
     3e0:	99 1f       	adc	r25, r25
     3e2:	82 0f       	add	r24, r18
     3e4:	93 1f       	adc	r25, r19
     3e6:	ac 01       	movw	r20, r24
     3e8:	49 58       	subi	r20, 0x89	; 137
     3ea:	5f 4f       	sbci	r21, 0xFF	; 255
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	9a 81       	ldd	r25, Y+2	; 0x02
     3f0:	9c 01       	movw	r18, r24
     3f2:	2e 5f       	subi	r18, 0xFE	; 254
     3f4:	3f 4f       	sbci	r19, 0xFF	; 255
     3f6:	ca 01       	movw	r24, r20
     3f8:	b9 01       	movw	r22, r18
     3fa:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     3fe:	80 91 9f 00 	lds	r24, 0x009F
     402:	88 23       	and	r24, r24
     404:	09 f0       	breq	.+2      	; 0x408 <prvCheckPendingReadyList+0x8a>
     406:	c1 cf       	rjmp	.-126    	; 0x38a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     408:	0f 90       	pop	r0
     40a:	0f 90       	pop	r0
     40c:	cf 91       	pop	r28
     40e:	df 91       	pop	r29
     410:	08 95       	ret

00000412 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     412:	df 93       	push	r29
     414:	cf 93       	push	r28
     416:	00 d0       	rcall	.+0      	; 0x418 <prvCheckDelayedList+0x6>
     418:	00 d0       	rcall	.+0      	; 0x41a <prvCheckDelayedList+0x8>
     41a:	cd b7       	in	r28, 0x3d	; 61
     41c:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     41e:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <xTaskGetTickCount>
     422:	20 91 73 00 	lds	r18, 0x0073
     426:	30 91 74 00 	lds	r19, 0x0074
     42a:	82 1b       	sub	r24, r18
     42c:	93 0b       	sbc	r25, r19
     42e:	90 93 76 00 	sts	0x0076, r25
     432:	80 93 75 00 	sts	0x0075, r24
     436:	85 c0       	rjmp	.+266    	; 0x542 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     438:	80 91 71 00 	lds	r24, 0x0071
     43c:	90 91 72 00 	lds	r25, 0x0072
     440:	01 96       	adiw	r24, 0x01	; 1
     442:	90 93 72 00 	sts	0x0072, r25
     446:	80 93 71 00 	sts	0x0071, r24
		xPassedTicks--;
     44a:	80 91 75 00 	lds	r24, 0x0075
     44e:	90 91 76 00 	lds	r25, 0x0076
     452:	01 97       	sbiw	r24, 0x01	; 1
     454:	90 93 76 00 	sts	0x0076, r25
     458:	80 93 75 00 	sts	0x0075, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     45c:	80 91 71 00 	lds	r24, 0x0071
     460:	90 91 72 00 	lds	r25, 0x0072
     464:	00 97       	sbiw	r24, 0x00	; 0
     466:	09 f0       	breq	.+2      	; 0x46a <prvCheckDelayedList+0x58>
     468:	64 c0       	rjmp	.+200    	; 0x532 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     46a:	80 91 9b 00 	lds	r24, 0x009B
     46e:	90 91 9c 00 	lds	r25, 0x009C
     472:	9a 83       	std	Y+2, r25	; 0x02
     474:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     476:	80 91 9d 00 	lds	r24, 0x009D
     47a:	90 91 9e 00 	lds	r25, 0x009E
     47e:	90 93 9c 00 	sts	0x009C, r25
     482:	80 93 9b 00 	sts	0x009B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     486:	89 81       	ldd	r24, Y+1	; 0x01
     488:	9a 81       	ldd	r25, Y+2	; 0x02
     48a:	90 93 9e 00 	sts	0x009E, r25
     48e:	80 93 9d 00 	sts	0x009D, r24
     492:	4f c0       	rjmp	.+158    	; 0x532 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     494:	e0 91 9b 00 	lds	r30, 0x009B
     498:	f0 91 9c 00 	lds	r31, 0x009C
     49c:	05 80       	ldd	r0, Z+5	; 0x05
     49e:	f6 81       	ldd	r31, Z+6	; 0x06
     4a0:	e0 2d       	mov	r30, r0
     4a2:	86 81       	ldd	r24, Z+6	; 0x06
     4a4:	97 81       	ldd	r25, Z+7	; 0x07
     4a6:	9c 83       	std	Y+4, r25	; 0x04
     4a8:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     4aa:	eb 81       	ldd	r30, Y+3	; 0x03
     4ac:	fc 81       	ldd	r31, Y+4	; 0x04
     4ae:	22 81       	ldd	r18, Z+2	; 0x02
     4b0:	33 81       	ldd	r19, Z+3	; 0x03
     4b2:	80 91 71 00 	lds	r24, 0x0071
     4b6:	90 91 72 00 	lds	r25, 0x0072
     4ba:	82 17       	cp	r24, r18
     4bc:	93 07       	cpc	r25, r19
     4be:	08 f4       	brcc	.+2      	; 0x4c2 <prvCheckDelayedList+0xb0>
     4c0:	40 c0       	rjmp	.+128    	; 0x542 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     4c2:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     4c4:	8b 81       	ldd	r24, Y+3	; 0x03
     4c6:	9c 81       	ldd	r25, Y+4	; 0x04
     4c8:	02 96       	adiw	r24, 0x02	; 2
     4ca:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     4ce:	eb 81       	ldd	r30, Y+3	; 0x03
     4d0:	fc 81       	ldd	r31, Y+4	; 0x04
     4d2:	84 89       	ldd	r24, Z+20	; 0x14
     4d4:	95 89       	ldd	r25, Z+21	; 0x15
     4d6:	00 97       	sbiw	r24, 0x00	; 0
     4d8:	29 f0       	breq	.+10     	; 0x4e4 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     4da:	8b 81       	ldd	r24, Y+3	; 0x03
     4dc:	9c 81       	ldd	r25, Y+4	; 0x04
     4de:	0c 96       	adiw	r24, 0x0c	; 12
     4e0:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     4e4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     4e6:	eb 81       	ldd	r30, Y+3	; 0x03
     4e8:	fc 81       	ldd	r31, Y+4	; 0x04
     4ea:	96 89       	ldd	r25, Z+22	; 0x16
     4ec:	80 91 70 00 	lds	r24, 0x0070
     4f0:	89 17       	cp	r24, r25
     4f2:	28 f4       	brcc	.+10     	; 0x4fe <prvCheckDelayedList+0xec>
     4f4:	eb 81       	ldd	r30, Y+3	; 0x03
     4f6:	fc 81       	ldd	r31, Y+4	; 0x04
     4f8:	86 89       	ldd	r24, Z+22	; 0x16
     4fa:	80 93 70 00 	sts	0x0070, r24
     4fe:	eb 81       	ldd	r30, Y+3	; 0x03
     500:	fc 81       	ldd	r31, Y+4	; 0x04
     502:	86 89       	ldd	r24, Z+22	; 0x16
     504:	28 2f       	mov	r18, r24
     506:	30 e0       	ldi	r19, 0x00	; 0
     508:	c9 01       	movw	r24, r18
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	88 0f       	add	r24, r24
     510:	99 1f       	adc	r25, r25
     512:	88 0f       	add	r24, r24
     514:	99 1f       	adc	r25, r25
     516:	82 0f       	add	r24, r18
     518:	93 1f       	adc	r25, r19
     51a:	ac 01       	movw	r20, r24
     51c:	49 58       	subi	r20, 0x89	; 137
     51e:	5f 4f       	sbci	r21, 0xFF	; 255
     520:	8b 81       	ldd	r24, Y+3	; 0x03
     522:	9c 81       	ldd	r25, Y+4	; 0x04
     524:	9c 01       	movw	r18, r24
     526:	2e 5f       	subi	r18, 0xFE	; 254
     528:	3f 4f       	sbci	r19, 0xFF	; 255
     52a:	ca 01       	movw	r24, r20
     52c:	b9 01       	movw	r22, r18
     52e:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     532:	e0 91 9b 00 	lds	r30, 0x009B
     536:	f0 91 9c 00 	lds	r31, 0x009C
     53a:	80 81       	ld	r24, Z
     53c:	88 23       	and	r24, r24
     53e:	09 f0       	breq	.+2      	; 0x542 <prvCheckDelayedList+0x130>
     540:	a9 cf       	rjmp	.-174    	; 0x494 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     542:	80 91 75 00 	lds	r24, 0x0075
     546:	90 91 76 00 	lds	r25, 0x0076
     54a:	00 97       	sbiw	r24, 0x00	; 0
     54c:	09 f0       	breq	.+2      	; 0x550 <prvCheckDelayedList+0x13e>
     54e:	74 cf       	rjmp	.-280    	; 0x438 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     550:	80 91 71 00 	lds	r24, 0x0071
     554:	90 91 72 00 	lds	r25, 0x0072
     558:	90 93 74 00 	sts	0x0074, r25
     55c:	80 93 73 00 	sts	0x0073, r24
}
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	0f 90       	pop	r0
     566:	0f 90       	pop	r0
     568:	cf 91       	pop	r28
     56a:	df 91       	pop	r29
     56c:	08 95       	ret

0000056e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     56e:	df 93       	push	r29
     570:	cf 93       	push	r28
     572:	00 d0       	rcall	.+0      	; 0x574 <vCoRoutineSchedule+0x6>
     574:	cd b7       	in	r28, 0x3d	; 61
     576:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     578:	0e 94 bf 01 	call	0x37e	; 0x37e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     57c:	0e 94 09 02 	call	0x412	; 0x412 <prvCheckDelayedList>
     580:	0a c0       	rjmp	.+20     	; 0x596 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     582:	80 91 70 00 	lds	r24, 0x0070
     586:	88 23       	and	r24, r24
     588:	09 f4       	brne	.+2      	; 0x58c <vCoRoutineSchedule+0x1e>
     58a:	66 c0       	rjmp	.+204    	; 0x658 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     58c:	80 91 70 00 	lds	r24, 0x0070
     590:	81 50       	subi	r24, 0x01	; 1
     592:	80 93 70 00 	sts	0x0070, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     596:	80 91 70 00 	lds	r24, 0x0070
     59a:	28 2f       	mov	r18, r24
     59c:	30 e0       	ldi	r19, 0x00	; 0
     59e:	c9 01       	movw	r24, r18
     5a0:	88 0f       	add	r24, r24
     5a2:	99 1f       	adc	r25, r25
     5a4:	88 0f       	add	r24, r24
     5a6:	99 1f       	adc	r25, r25
     5a8:	88 0f       	add	r24, r24
     5aa:	99 1f       	adc	r25, r25
     5ac:	82 0f       	add	r24, r18
     5ae:	93 1f       	adc	r25, r19
     5b0:	fc 01       	movw	r30, r24
     5b2:	e9 58       	subi	r30, 0x89	; 137
     5b4:	ff 4f       	sbci	r31, 0xFF	; 255
     5b6:	80 81       	ld	r24, Z
     5b8:	88 23       	and	r24, r24
     5ba:	19 f3       	breq	.-58     	; 0x582 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     5bc:	80 91 70 00 	lds	r24, 0x0070
     5c0:	28 2f       	mov	r18, r24
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	c9 01       	movw	r24, r18
     5c6:	88 0f       	add	r24, r24
     5c8:	99 1f       	adc	r25, r25
     5ca:	88 0f       	add	r24, r24
     5cc:	99 1f       	adc	r25, r25
     5ce:	88 0f       	add	r24, r24
     5d0:	99 1f       	adc	r25, r25
     5d2:	82 0f       	add	r24, r18
     5d4:	93 1f       	adc	r25, r19
     5d6:	89 58       	subi	r24, 0x89	; 137
     5d8:	9f 4f       	sbci	r25, 0xFF	; 255
     5da:	9a 83       	std	Y+2, r25	; 0x02
     5dc:	89 83       	std	Y+1, r24	; 0x01
     5de:	e9 81       	ldd	r30, Y+1	; 0x01
     5e0:	fa 81       	ldd	r31, Y+2	; 0x02
     5e2:	01 80       	ldd	r0, Z+1	; 0x01
     5e4:	f2 81       	ldd	r31, Z+2	; 0x02
     5e6:	e0 2d       	mov	r30, r0
     5e8:	82 81       	ldd	r24, Z+2	; 0x02
     5ea:	93 81       	ldd	r25, Z+3	; 0x03
     5ec:	e9 81       	ldd	r30, Y+1	; 0x01
     5ee:	fa 81       	ldd	r31, Y+2	; 0x02
     5f0:	92 83       	std	Z+2, r25	; 0x02
     5f2:	81 83       	std	Z+1, r24	; 0x01
     5f4:	e9 81       	ldd	r30, Y+1	; 0x01
     5f6:	fa 81       	ldd	r31, Y+2	; 0x02
     5f8:	21 81       	ldd	r18, Z+1	; 0x01
     5fa:	32 81       	ldd	r19, Z+2	; 0x02
     5fc:	89 81       	ldd	r24, Y+1	; 0x01
     5fe:	9a 81       	ldd	r25, Y+2	; 0x02
     600:	03 96       	adiw	r24, 0x03	; 3
     602:	28 17       	cp	r18, r24
     604:	39 07       	cpc	r19, r25
     606:	59 f4       	brne	.+22     	; 0x61e <vCoRoutineSchedule+0xb0>
     608:	e9 81       	ldd	r30, Y+1	; 0x01
     60a:	fa 81       	ldd	r31, Y+2	; 0x02
     60c:	01 80       	ldd	r0, Z+1	; 0x01
     60e:	f2 81       	ldd	r31, Z+2	; 0x02
     610:	e0 2d       	mov	r30, r0
     612:	82 81       	ldd	r24, Z+2	; 0x02
     614:	93 81       	ldd	r25, Z+3	; 0x03
     616:	e9 81       	ldd	r30, Y+1	; 0x01
     618:	fa 81       	ldd	r31, Y+2	; 0x02
     61a:	92 83       	std	Z+2, r25	; 0x02
     61c:	81 83       	std	Z+1, r24	; 0x01
     61e:	e9 81       	ldd	r30, Y+1	; 0x01
     620:	fa 81       	ldd	r31, Y+2	; 0x02
     622:	01 80       	ldd	r0, Z+1	; 0x01
     624:	f2 81       	ldd	r31, Z+2	; 0x02
     626:	e0 2d       	mov	r30, r0
     628:	86 81       	ldd	r24, Z+6	; 0x06
     62a:	97 81       	ldd	r25, Z+7	; 0x07
     62c:	90 93 6f 00 	sts	0x006F, r25
     630:	80 93 6e 00 	sts	0x006E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     634:	e0 91 6e 00 	lds	r30, 0x006E
     638:	f0 91 6f 00 	lds	r31, 0x006F
     63c:	40 81       	ld	r20, Z
     63e:	51 81       	ldd	r21, Z+1	; 0x01
     640:	80 91 6e 00 	lds	r24, 0x006E
     644:	90 91 6f 00 	lds	r25, 0x006F
     648:	e0 91 6e 00 	lds	r30, 0x006E
     64c:	f0 91 6f 00 	lds	r31, 0x006F
     650:	27 89       	ldd	r18, Z+23	; 0x17
     652:	62 2f       	mov	r22, r18
     654:	fa 01       	movw	r30, r20
     656:	09 95       	icall

	return;
}
     658:	0f 90       	pop	r0
     65a:	0f 90       	pop	r0
     65c:	cf 91       	pop	r28
     65e:	df 91       	pop	r29
     660:	08 95       	ret

00000662 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     662:	df 93       	push	r29
     664:	cf 93       	push	r28
     666:	0f 92       	push	r0
     668:	cd b7       	in	r28, 0x3d	; 61
     66a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     66c:	19 82       	std	Y+1, r1	; 0x01
     66e:	13 c0       	rjmp	.+38     	; 0x696 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     670:	89 81       	ldd	r24, Y+1	; 0x01
     672:	28 2f       	mov	r18, r24
     674:	30 e0       	ldi	r19, 0x00	; 0
     676:	c9 01       	movw	r24, r18
     678:	88 0f       	add	r24, r24
     67a:	99 1f       	adc	r25, r25
     67c:	88 0f       	add	r24, r24
     67e:	99 1f       	adc	r25, r25
     680:	88 0f       	add	r24, r24
     682:	99 1f       	adc	r25, r25
     684:	82 0f       	add	r24, r18
     686:	93 1f       	adc	r25, r19
     688:	89 58       	subi	r24, 0x89	; 137
     68a:	9f 4f       	sbci	r25, 0xFF	; 255
     68c:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     690:	89 81       	ldd	r24, Y+1	; 0x01
     692:	8f 5f       	subi	r24, 0xFF	; 255
     694:	89 83       	std	Y+1, r24	; 0x01
     696:	89 81       	ldd	r24, Y+1	; 0x01
     698:	82 30       	cpi	r24, 0x02	; 2
     69a:	50 f3       	brcs	.-44     	; 0x670 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     69c:	89 e8       	ldi	r24, 0x89	; 137
     69e:	90 e0       	ldi	r25, 0x00	; 0
     6a0:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     6a4:	82 e9       	ldi	r24, 0x92	; 146
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     6ac:	8f e9       	ldi	r24, 0x9F	; 159
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     6b4:	89 e8       	ldi	r24, 0x89	; 137
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	90 93 9c 00 	sts	0x009C, r25
     6bc:	80 93 9b 00 	sts	0x009B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     6c0:	82 e9       	ldi	r24, 0x92	; 146
     6c2:	90 e0       	ldi	r25, 0x00	; 0
     6c4:	90 93 9e 00 	sts	0x009E, r25
     6c8:	80 93 9d 00 	sts	0x009D, r24
}
     6cc:	0f 90       	pop	r0
     6ce:	cf 91       	pop	r28
     6d0:	df 91       	pop	r29
     6d2:	08 95       	ret

000006d4 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     6d4:	df 93       	push	r29
     6d6:	cf 93       	push	r28
     6d8:	00 d0       	rcall	.+0      	; 0x6da <xCoRoutineRemoveFromEventList+0x6>
     6da:	00 d0       	rcall	.+0      	; 0x6dc <xCoRoutineRemoveFromEventList+0x8>
     6dc:	0f 92       	push	r0
     6de:	cd b7       	in	r28, 0x3d	; 61
     6e0:	de b7       	in	r29, 0x3e	; 62
     6e2:	9d 83       	std	Y+5, r25	; 0x05
     6e4:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     6e6:	ec 81       	ldd	r30, Y+4	; 0x04
     6e8:	fd 81       	ldd	r31, Y+5	; 0x05
     6ea:	05 80       	ldd	r0, Z+5	; 0x05
     6ec:	f6 81       	ldd	r31, Z+6	; 0x06
     6ee:	e0 2d       	mov	r30, r0
     6f0:	86 81       	ldd	r24, Z+6	; 0x06
     6f2:	97 81       	ldd	r25, Z+7	; 0x07
     6f4:	9b 83       	std	Y+3, r25	; 0x03
     6f6:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     6f8:	8a 81       	ldd	r24, Y+2	; 0x02
     6fa:	9b 81       	ldd	r25, Y+3	; 0x03
     6fc:	0c 96       	adiw	r24, 0x0c	; 12
     6fe:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     702:	8a 81       	ldd	r24, Y+2	; 0x02
     704:	9b 81       	ldd	r25, Y+3	; 0x03
     706:	9c 01       	movw	r18, r24
     708:	24 5f       	subi	r18, 0xF4	; 244
     70a:	3f 4f       	sbci	r19, 0xFF	; 255
     70c:	8f e9       	ldi	r24, 0x9F	; 159
     70e:	90 e0       	ldi	r25, 0x00	; 0
     710:	b9 01       	movw	r22, r18
     712:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     716:	ea 81       	ldd	r30, Y+2	; 0x02
     718:	fb 81       	ldd	r31, Y+3	; 0x03
     71a:	96 89       	ldd	r25, Z+22	; 0x16
     71c:	e0 91 6e 00 	lds	r30, 0x006E
     720:	f0 91 6f 00 	lds	r31, 0x006F
     724:	86 89       	ldd	r24, Z+22	; 0x16
     726:	98 17       	cp	r25, r24
     728:	18 f0       	brcs	.+6      	; 0x730 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     72a:	81 e0       	ldi	r24, 0x01	; 1
     72c:	89 83       	std	Y+1, r24	; 0x01
     72e:	01 c0       	rjmp	.+2      	; 0x732 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     730:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     732:	89 81       	ldd	r24, Y+1	; 0x01
}
     734:	0f 90       	pop	r0
     736:	0f 90       	pop	r0
     738:	0f 90       	pop	r0
     73a:	0f 90       	pop	r0
     73c:	0f 90       	pop	r0
     73e:	cf 91       	pop	r28
     740:	df 91       	pop	r29
     742:	08 95       	ret

00000744 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     744:	df 93       	push	r29
     746:	cf 93       	push	r28
     748:	00 d0       	rcall	.+0      	; 0x74a <pvPortMalloc+0x6>
     74a:	00 d0       	rcall	.+0      	; 0x74c <pvPortMalloc+0x8>
     74c:	cd b7       	in	r28, 0x3d	; 61
     74e:	de b7       	in	r29, 0x3e	; 62
     750:	9c 83       	std	Y+4, r25	; 0x04
     752:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     754:	1a 82       	std	Y+2, r1	; 0x02
     756:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     758:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     75c:	80 91 a8 00 	lds	r24, 0x00A8
     760:	90 91 a9 00 	lds	r25, 0x00A9
     764:	2b 81       	ldd	r18, Y+3	; 0x03
     766:	3c 81       	ldd	r19, Y+4	; 0x04
     768:	82 0f       	add	r24, r18
     76a:	93 1f       	adc	r25, r19
     76c:	22 e0       	ldi	r18, 0x02	; 2
     76e:	88 35       	cpi	r24, 0x58	; 88
     770:	92 07       	cpc	r25, r18
     772:	18 f5       	brcc	.+70     	; 0x7ba <pvPortMalloc+0x76>
     774:	20 91 a8 00 	lds	r18, 0x00A8
     778:	30 91 a9 00 	lds	r19, 0x00A9
     77c:	8b 81       	ldd	r24, Y+3	; 0x03
     77e:	9c 81       	ldd	r25, Y+4	; 0x04
     780:	28 0f       	add	r18, r24
     782:	39 1f       	adc	r19, r25
     784:	80 91 a8 00 	lds	r24, 0x00A8
     788:	90 91 a9 00 	lds	r25, 0x00A9
     78c:	82 17       	cp	r24, r18
     78e:	93 07       	cpc	r25, r19
     790:	a0 f4       	brcc	.+40     	; 0x7ba <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     792:	80 91 a8 00 	lds	r24, 0x00A8
     796:	90 91 a9 00 	lds	r25, 0x00A9
     79a:	86 55       	subi	r24, 0x56	; 86
     79c:	9f 4f       	sbci	r25, 0xFF	; 255
     79e:	9a 83       	std	Y+2, r25	; 0x02
     7a0:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     7a2:	20 91 a8 00 	lds	r18, 0x00A8
     7a6:	30 91 a9 00 	lds	r19, 0x00A9
     7aa:	8b 81       	ldd	r24, Y+3	; 0x03
     7ac:	9c 81       	ldd	r25, Y+4	; 0x04
     7ae:	82 0f       	add	r24, r18
     7b0:	93 1f       	adc	r25, r19
     7b2:	90 93 a9 00 	sts	0x00A9, r25
     7b6:	80 93 a8 00 	sts	0x00A8, r24
		}	
	}
	xTaskResumeAll();
     7ba:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     7be:	89 81       	ldd	r24, Y+1	; 0x01
     7c0:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	0f 90       	pop	r0
     7c8:	0f 90       	pop	r0
     7ca:	cf 91       	pop	r28
     7cc:	df 91       	pop	r29
     7ce:	08 95       	ret

000007d0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7d0:	df 93       	push	r29
     7d2:	cf 93       	push	r28
     7d4:	00 d0       	rcall	.+0      	; 0x7d6 <vPortFree+0x6>
     7d6:	cd b7       	in	r28, 0x3d	; 61
     7d8:	de b7       	in	r29, 0x3e	; 62
     7da:	9a 83       	std	Y+2, r25	; 0x02
     7dc:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     7de:	0f 90       	pop	r0
     7e0:	0f 90       	pop	r0
     7e2:	cf 91       	pop	r28
     7e4:	df 91       	pop	r29
     7e6:	08 95       	ret

000007e8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7e8:	df 93       	push	r29
     7ea:	cf 93       	push	r28
     7ec:	cd b7       	in	r28, 0x3d	; 61
     7ee:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7f0:	10 92 a9 00 	sts	0x00A9, r1
     7f4:	10 92 a8 00 	sts	0x00A8, r1
}
     7f8:	cf 91       	pop	r28
     7fa:	df 91       	pop	r29
     7fc:	08 95       	ret

000007fe <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7fe:	df 93       	push	r29
     800:	cf 93       	push	r28
     802:	cd b7       	in	r28, 0x3d	; 61
     804:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     806:	20 91 a8 00 	lds	r18, 0x00A8
     80a:	30 91 a9 00 	lds	r19, 0x00A9
     80e:	88 e5       	ldi	r24, 0x58	; 88
     810:	92 e0       	ldi	r25, 0x02	; 2
     812:	82 1b       	sub	r24, r18
     814:	93 0b       	sbc	r25, r19
}
     816:	cf 91       	pop	r28
     818:	df 91       	pop	r29
     81a:	08 95       	ret

0000081c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     81c:	df 93       	push	r29
     81e:	cf 93       	push	r28
     820:	00 d0       	rcall	.+0      	; 0x822 <vListInitialise+0x6>
     822:	cd b7       	in	r28, 0x3d	; 61
     824:	de b7       	in	r29, 0x3e	; 62
     826:	9a 83       	std	Y+2, r25	; 0x02
     828:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     82a:	89 81       	ldd	r24, Y+1	; 0x01
     82c:	9a 81       	ldd	r25, Y+2	; 0x02
     82e:	03 96       	adiw	r24, 0x03	; 3
     830:	e9 81       	ldd	r30, Y+1	; 0x01
     832:	fa 81       	ldd	r31, Y+2	; 0x02
     834:	92 83       	std	Z+2, r25	; 0x02
     836:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     838:	e9 81       	ldd	r30, Y+1	; 0x01
     83a:	fa 81       	ldd	r31, Y+2	; 0x02
     83c:	8f ef       	ldi	r24, 0xFF	; 255
     83e:	9f ef       	ldi	r25, 0xFF	; 255
     840:	94 83       	std	Z+4, r25	; 0x04
     842:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     844:	89 81       	ldd	r24, Y+1	; 0x01
     846:	9a 81       	ldd	r25, Y+2	; 0x02
     848:	03 96       	adiw	r24, 0x03	; 3
     84a:	e9 81       	ldd	r30, Y+1	; 0x01
     84c:	fa 81       	ldd	r31, Y+2	; 0x02
     84e:	96 83       	std	Z+6, r25	; 0x06
     850:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     852:	89 81       	ldd	r24, Y+1	; 0x01
     854:	9a 81       	ldd	r25, Y+2	; 0x02
     856:	03 96       	adiw	r24, 0x03	; 3
     858:	e9 81       	ldd	r30, Y+1	; 0x01
     85a:	fa 81       	ldd	r31, Y+2	; 0x02
     85c:	90 87       	std	Z+8, r25	; 0x08
     85e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     860:	e9 81       	ldd	r30, Y+1	; 0x01
     862:	fa 81       	ldd	r31, Y+2	; 0x02
     864:	10 82       	st	Z, r1
}
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	cf 91       	pop	r28
     86c:	df 91       	pop	r29
     86e:	08 95       	ret

00000870 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     870:	df 93       	push	r29
     872:	cf 93       	push	r28
     874:	00 d0       	rcall	.+0      	; 0x876 <vListInitialiseItem+0x6>
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	9a 83       	std	Y+2, r25	; 0x02
     87c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     87e:	e9 81       	ldd	r30, Y+1	; 0x01
     880:	fa 81       	ldd	r31, Y+2	; 0x02
     882:	11 86       	std	Z+9, r1	; 0x09
     884:	10 86       	std	Z+8, r1	; 0x08
}
     886:	0f 90       	pop	r0
     888:	0f 90       	pop	r0
     88a:	cf 91       	pop	r28
     88c:	df 91       	pop	r29
     88e:	08 95       	ret

00000890 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     890:	df 93       	push	r29
     892:	cf 93       	push	r28
     894:	00 d0       	rcall	.+0      	; 0x896 <vListInsertEnd+0x6>
     896:	00 d0       	rcall	.+0      	; 0x898 <vListInsertEnd+0x8>
     898:	00 d0       	rcall	.+0      	; 0x89a <vListInsertEnd+0xa>
     89a:	cd b7       	in	r28, 0x3d	; 61
     89c:	de b7       	in	r29, 0x3e	; 62
     89e:	9c 83       	std	Y+4, r25	; 0x04
     8a0:	8b 83       	std	Y+3, r24	; 0x03
     8a2:	7e 83       	std	Y+6, r23	; 0x06
     8a4:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     8a6:	eb 81       	ldd	r30, Y+3	; 0x03
     8a8:	fc 81       	ldd	r31, Y+4	; 0x04
     8aa:	81 81       	ldd	r24, Z+1	; 0x01
     8ac:	92 81       	ldd	r25, Z+2	; 0x02
     8ae:	9a 83       	std	Y+2, r25	; 0x02
     8b0:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     8b2:	e9 81       	ldd	r30, Y+1	; 0x01
     8b4:	fa 81       	ldd	r31, Y+2	; 0x02
     8b6:	82 81       	ldd	r24, Z+2	; 0x02
     8b8:	93 81       	ldd	r25, Z+3	; 0x03
     8ba:	ed 81       	ldd	r30, Y+5	; 0x05
     8bc:	fe 81       	ldd	r31, Y+6	; 0x06
     8be:	93 83       	std	Z+3, r25	; 0x03
     8c0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     8c2:	eb 81       	ldd	r30, Y+3	; 0x03
     8c4:	fc 81       	ldd	r31, Y+4	; 0x04
     8c6:	81 81       	ldd	r24, Z+1	; 0x01
     8c8:	92 81       	ldd	r25, Z+2	; 0x02
     8ca:	ed 81       	ldd	r30, Y+5	; 0x05
     8cc:	fe 81       	ldd	r31, Y+6	; 0x06
     8ce:	95 83       	std	Z+5, r25	; 0x05
     8d0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8d2:	e9 81       	ldd	r30, Y+1	; 0x01
     8d4:	fa 81       	ldd	r31, Y+2	; 0x02
     8d6:	02 80       	ldd	r0, Z+2	; 0x02
     8d8:	f3 81       	ldd	r31, Z+3	; 0x03
     8da:	e0 2d       	mov	r30, r0
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	9e 81       	ldd	r25, Y+6	; 0x06
     8e0:	95 83       	std	Z+5, r25	; 0x05
     8e2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     8e4:	8d 81       	ldd	r24, Y+5	; 0x05
     8e6:	9e 81       	ldd	r25, Y+6	; 0x06
     8e8:	e9 81       	ldd	r30, Y+1	; 0x01
     8ea:	fa 81       	ldd	r31, Y+2	; 0x02
     8ec:	93 83       	std	Z+3, r25	; 0x03
     8ee:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     8f0:	8d 81       	ldd	r24, Y+5	; 0x05
     8f2:	9e 81       	ldd	r25, Y+6	; 0x06
     8f4:	eb 81       	ldd	r30, Y+3	; 0x03
     8f6:	fc 81       	ldd	r31, Y+4	; 0x04
     8f8:	92 83       	std	Z+2, r25	; 0x02
     8fa:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8fc:	ed 81       	ldd	r30, Y+5	; 0x05
     8fe:	fe 81       	ldd	r31, Y+6	; 0x06
     900:	8b 81       	ldd	r24, Y+3	; 0x03
     902:	9c 81       	ldd	r25, Y+4	; 0x04
     904:	91 87       	std	Z+9, r25	; 0x09
     906:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     908:	eb 81       	ldd	r30, Y+3	; 0x03
     90a:	fc 81       	ldd	r31, Y+4	; 0x04
     90c:	80 81       	ld	r24, Z
     90e:	8f 5f       	subi	r24, 0xFF	; 255
     910:	eb 81       	ldd	r30, Y+3	; 0x03
     912:	fc 81       	ldd	r31, Y+4	; 0x04
     914:	80 83       	st	Z, r24
}
     916:	26 96       	adiw	r28, 0x06	; 6
     918:	0f b6       	in	r0, 0x3f	; 63
     91a:	f8 94       	cli
     91c:	de bf       	out	0x3e, r29	; 62
     91e:	0f be       	out	0x3f, r0	; 63
     920:	cd bf       	out	0x3d, r28	; 61
     922:	cf 91       	pop	r28
     924:	df 91       	pop	r29
     926:	08 95       	ret

00000928 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     928:	df 93       	push	r29
     92a:	cf 93       	push	r28
     92c:	cd b7       	in	r28, 0x3d	; 61
     92e:	de b7       	in	r29, 0x3e	; 62
     930:	28 97       	sbiw	r28, 0x08	; 8
     932:	0f b6       	in	r0, 0x3f	; 63
     934:	f8 94       	cli
     936:	de bf       	out	0x3e, r29	; 62
     938:	0f be       	out	0x3f, r0	; 63
     93a:	cd bf       	out	0x3d, r28	; 61
     93c:	9e 83       	std	Y+6, r25	; 0x06
     93e:	8d 83       	std	Y+5, r24	; 0x05
     940:	78 87       	std	Y+8, r23	; 0x08
     942:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     944:	ef 81       	ldd	r30, Y+7	; 0x07
     946:	f8 85       	ldd	r31, Y+8	; 0x08
     948:	80 81       	ld	r24, Z
     94a:	91 81       	ldd	r25, Z+1	; 0x01
     94c:	9a 83       	std	Y+2, r25	; 0x02
     94e:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     950:	89 81       	ldd	r24, Y+1	; 0x01
     952:	9a 81       	ldd	r25, Y+2	; 0x02
     954:	2f ef       	ldi	r18, 0xFF	; 255
     956:	8f 3f       	cpi	r24, 0xFF	; 255
     958:	92 07       	cpc	r25, r18
     95a:	39 f4       	brne	.+14     	; 0x96a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     95c:	ed 81       	ldd	r30, Y+5	; 0x05
     95e:	fe 81       	ldd	r31, Y+6	; 0x06
     960:	87 81       	ldd	r24, Z+7	; 0x07
     962:	90 85       	ldd	r25, Z+8	; 0x08
     964:	9c 83       	std	Y+4, r25	; 0x04
     966:	8b 83       	std	Y+3, r24	; 0x03
     968:	18 c0       	rjmp	.+48     	; 0x99a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     96a:	8d 81       	ldd	r24, Y+5	; 0x05
     96c:	9e 81       	ldd	r25, Y+6	; 0x06
     96e:	03 96       	adiw	r24, 0x03	; 3
     970:	9c 83       	std	Y+4, r25	; 0x04
     972:	8b 83       	std	Y+3, r24	; 0x03
     974:	06 c0       	rjmp	.+12     	; 0x982 <vListInsert+0x5a>
     976:	eb 81       	ldd	r30, Y+3	; 0x03
     978:	fc 81       	ldd	r31, Y+4	; 0x04
     97a:	82 81       	ldd	r24, Z+2	; 0x02
     97c:	93 81       	ldd	r25, Z+3	; 0x03
     97e:	9c 83       	std	Y+4, r25	; 0x04
     980:	8b 83       	std	Y+3, r24	; 0x03
     982:	eb 81       	ldd	r30, Y+3	; 0x03
     984:	fc 81       	ldd	r31, Y+4	; 0x04
     986:	02 80       	ldd	r0, Z+2	; 0x02
     988:	f3 81       	ldd	r31, Z+3	; 0x03
     98a:	e0 2d       	mov	r30, r0
     98c:	20 81       	ld	r18, Z
     98e:	31 81       	ldd	r19, Z+1	; 0x01
     990:	89 81       	ldd	r24, Y+1	; 0x01
     992:	9a 81       	ldd	r25, Y+2	; 0x02
     994:	82 17       	cp	r24, r18
     996:	93 07       	cpc	r25, r19
     998:	70 f7       	brcc	.-36     	; 0x976 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     99a:	eb 81       	ldd	r30, Y+3	; 0x03
     99c:	fc 81       	ldd	r31, Y+4	; 0x04
     99e:	82 81       	ldd	r24, Z+2	; 0x02
     9a0:	93 81       	ldd	r25, Z+3	; 0x03
     9a2:	ef 81       	ldd	r30, Y+7	; 0x07
     9a4:	f8 85       	ldd	r31, Y+8	; 0x08
     9a6:	93 83       	std	Z+3, r25	; 0x03
     9a8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     9aa:	ef 81       	ldd	r30, Y+7	; 0x07
     9ac:	f8 85       	ldd	r31, Y+8	; 0x08
     9ae:	02 80       	ldd	r0, Z+2	; 0x02
     9b0:	f3 81       	ldd	r31, Z+3	; 0x03
     9b2:	e0 2d       	mov	r30, r0
     9b4:	8f 81       	ldd	r24, Y+7	; 0x07
     9b6:	98 85       	ldd	r25, Y+8	; 0x08
     9b8:	95 83       	std	Z+5, r25	; 0x05
     9ba:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9bc:	ef 81       	ldd	r30, Y+7	; 0x07
     9be:	f8 85       	ldd	r31, Y+8	; 0x08
     9c0:	8b 81       	ldd	r24, Y+3	; 0x03
     9c2:	9c 81       	ldd	r25, Y+4	; 0x04
     9c4:	95 83       	std	Z+5, r25	; 0x05
     9c6:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     9c8:	8f 81       	ldd	r24, Y+7	; 0x07
     9ca:	98 85       	ldd	r25, Y+8	; 0x08
     9cc:	eb 81       	ldd	r30, Y+3	; 0x03
     9ce:	fc 81       	ldd	r31, Y+4	; 0x04
     9d0:	93 83       	std	Z+3, r25	; 0x03
     9d2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9d4:	ef 81       	ldd	r30, Y+7	; 0x07
     9d6:	f8 85       	ldd	r31, Y+8	; 0x08
     9d8:	8d 81       	ldd	r24, Y+5	; 0x05
     9da:	9e 81       	ldd	r25, Y+6	; 0x06
     9dc:	91 87       	std	Z+9, r25	; 0x09
     9de:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9e0:	ed 81       	ldd	r30, Y+5	; 0x05
     9e2:	fe 81       	ldd	r31, Y+6	; 0x06
     9e4:	80 81       	ld	r24, Z
     9e6:	8f 5f       	subi	r24, 0xFF	; 255
     9e8:	ed 81       	ldd	r30, Y+5	; 0x05
     9ea:	fe 81       	ldd	r31, Y+6	; 0x06
     9ec:	80 83       	st	Z, r24
}
     9ee:	28 96       	adiw	r28, 0x08	; 8
     9f0:	0f b6       	in	r0, 0x3f	; 63
     9f2:	f8 94       	cli
     9f4:	de bf       	out	0x3e, r29	; 62
     9f6:	0f be       	out	0x3f, r0	; 63
     9f8:	cd bf       	out	0x3d, r28	; 61
     9fa:	cf 91       	pop	r28
     9fc:	df 91       	pop	r29
     9fe:	08 95       	ret

00000a00 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     a00:	df 93       	push	r29
     a02:	cf 93       	push	r28
     a04:	00 d0       	rcall	.+0      	; 0xa06 <vListRemove+0x6>
     a06:	00 d0       	rcall	.+0      	; 0xa08 <vListRemove+0x8>
     a08:	cd b7       	in	r28, 0x3d	; 61
     a0a:	de b7       	in	r29, 0x3e	; 62
     a0c:	9c 83       	std	Y+4, r25	; 0x04
     a0e:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a10:	eb 81       	ldd	r30, Y+3	; 0x03
     a12:	fc 81       	ldd	r31, Y+4	; 0x04
     a14:	a2 81       	ldd	r26, Z+2	; 0x02
     a16:	b3 81       	ldd	r27, Z+3	; 0x03
     a18:	eb 81       	ldd	r30, Y+3	; 0x03
     a1a:	fc 81       	ldd	r31, Y+4	; 0x04
     a1c:	84 81       	ldd	r24, Z+4	; 0x04
     a1e:	95 81       	ldd	r25, Z+5	; 0x05
     a20:	15 96       	adiw	r26, 0x05	; 5
     a22:	9c 93       	st	X, r25
     a24:	8e 93       	st	-X, r24
     a26:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a28:	eb 81       	ldd	r30, Y+3	; 0x03
     a2a:	fc 81       	ldd	r31, Y+4	; 0x04
     a2c:	a4 81       	ldd	r26, Z+4	; 0x04
     a2e:	b5 81       	ldd	r27, Z+5	; 0x05
     a30:	eb 81       	ldd	r30, Y+3	; 0x03
     a32:	fc 81       	ldd	r31, Y+4	; 0x04
     a34:	82 81       	ldd	r24, Z+2	; 0x02
     a36:	93 81       	ldd	r25, Z+3	; 0x03
     a38:	13 96       	adiw	r26, 0x03	; 3
     a3a:	9c 93       	st	X, r25
     a3c:	8e 93       	st	-X, r24
     a3e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     a40:	eb 81       	ldd	r30, Y+3	; 0x03
     a42:	fc 81       	ldd	r31, Y+4	; 0x04
     a44:	80 85       	ldd	r24, Z+8	; 0x08
     a46:	91 85       	ldd	r25, Z+9	; 0x09
     a48:	9a 83       	std	Y+2, r25	; 0x02
     a4a:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a4c:	e9 81       	ldd	r30, Y+1	; 0x01
     a4e:	fa 81       	ldd	r31, Y+2	; 0x02
     a50:	21 81       	ldd	r18, Z+1	; 0x01
     a52:	32 81       	ldd	r19, Z+2	; 0x02
     a54:	8b 81       	ldd	r24, Y+3	; 0x03
     a56:	9c 81       	ldd	r25, Y+4	; 0x04
     a58:	28 17       	cp	r18, r24
     a5a:	39 07       	cpc	r19, r25
     a5c:	41 f4       	brne	.+16     	; 0xa6e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a5e:	eb 81       	ldd	r30, Y+3	; 0x03
     a60:	fc 81       	ldd	r31, Y+4	; 0x04
     a62:	84 81       	ldd	r24, Z+4	; 0x04
     a64:	95 81       	ldd	r25, Z+5	; 0x05
     a66:	e9 81       	ldd	r30, Y+1	; 0x01
     a68:	fa 81       	ldd	r31, Y+2	; 0x02
     a6a:	92 83       	std	Z+2, r25	; 0x02
     a6c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a6e:	eb 81       	ldd	r30, Y+3	; 0x03
     a70:	fc 81       	ldd	r31, Y+4	; 0x04
     a72:	11 86       	std	Z+9, r1	; 0x09
     a74:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a76:	e9 81       	ldd	r30, Y+1	; 0x01
     a78:	fa 81       	ldd	r31, Y+2	; 0x02
     a7a:	80 81       	ld	r24, Z
     a7c:	81 50       	subi	r24, 0x01	; 1
     a7e:	e9 81       	ldd	r30, Y+1	; 0x01
     a80:	fa 81       	ldd	r31, Y+2	; 0x02
     a82:	80 83       	st	Z, r24
}
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	0f 90       	pop	r0
     a8c:	cf 91       	pop	r28
     a8e:	df 91       	pop	r29
     a90:	08 95       	ret

00000a92 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     a92:	df 93       	push	r29
     a94:	cf 93       	push	r28
     a96:	cd b7       	in	r28, 0x3d	; 61
     a98:	de b7       	in	r29, 0x3e	; 62
     a9a:	28 97       	sbiw	r28, 0x08	; 8
     a9c:	0f b6       	in	r0, 0x3f	; 63
     a9e:	f8 94       	cli
     aa0:	de bf       	out	0x3e, r29	; 62
     aa2:	0f be       	out	0x3f, r0	; 63
     aa4:	cd bf       	out	0x3d, r28	; 61
     aa6:	9c 83       	std	Y+4, r25	; 0x04
     aa8:	8b 83       	std	Y+3, r24	; 0x03
     aaa:	7e 83       	std	Y+6, r23	; 0x06
     aac:	6d 83       	std	Y+5, r22	; 0x05
     aae:	58 87       	std	Y+8, r21	; 0x08
     ab0:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     ab2:	eb 81       	ldd	r30, Y+3	; 0x03
     ab4:	fc 81       	ldd	r31, Y+4	; 0x04
     ab6:	81 e1       	ldi	r24, 0x11	; 17
     ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	9c 83       	std	Y+4, r25	; 0x04
     ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     ac4:	eb 81       	ldd	r30, Y+3	; 0x03
     ac6:	fc 81       	ldd	r31, Y+4	; 0x04
     ac8:	82 e2       	ldi	r24, 0x22	; 34
     aca:	80 83       	st	Z, r24
	pxTopOfStack--;
     acc:	8b 81       	ldd	r24, Y+3	; 0x03
     ace:	9c 81       	ldd	r25, Y+4	; 0x04
     ad0:	01 97       	sbiw	r24, 0x01	; 1
     ad2:	9c 83       	std	Y+4, r25	; 0x04
     ad4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ad6:	eb 81       	ldd	r30, Y+3	; 0x03
     ad8:	fc 81       	ldd	r31, Y+4	; 0x04
     ada:	83 e3       	ldi	r24, 0x33	; 51
     adc:	80 83       	st	Z, r24
	pxTopOfStack--;
     ade:	8b 81       	ldd	r24, Y+3	; 0x03
     ae0:	9c 81       	ldd	r25, Y+4	; 0x04
     ae2:	01 97       	sbiw	r24, 0x01	; 1
     ae4:	9c 83       	std	Y+4, r25	; 0x04
     ae6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     ae8:	8d 81       	ldd	r24, Y+5	; 0x05
     aea:	9e 81       	ldd	r25, Y+6	; 0x06
     aec:	9a 83       	std	Y+2, r25	; 0x02
     aee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	eb 81       	ldd	r30, Y+3	; 0x03
     af4:	fc 81       	ldd	r31, Y+4	; 0x04
     af6:	80 83       	st	Z, r24
	pxTopOfStack--;
     af8:	8b 81       	ldd	r24, Y+3	; 0x03
     afa:	9c 81       	ldd	r25, Y+4	; 0x04
     afc:	01 97       	sbiw	r24, 0x01	; 1
     afe:	9c 83       	std	Y+4, r25	; 0x04
     b00:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     b02:	89 81       	ldd	r24, Y+1	; 0x01
     b04:	9a 81       	ldd	r25, Y+2	; 0x02
     b06:	89 2f       	mov	r24, r25
     b08:	99 27       	eor	r25, r25
     b0a:	9a 83       	std	Y+2, r25	; 0x02
     b0c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b0e:	89 81       	ldd	r24, Y+1	; 0x01
     b10:	eb 81       	ldd	r30, Y+3	; 0x03
     b12:	fc 81       	ldd	r31, Y+4	; 0x04
     b14:	80 83       	st	Z, r24
	pxTopOfStack--;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	9c 81       	ldd	r25, Y+4	; 0x04
     b1a:	01 97       	sbiw	r24, 0x01	; 1
     b1c:	9c 83       	std	Y+4, r25	; 0x04
     b1e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     b20:	eb 81       	ldd	r30, Y+3	; 0x03
     b22:	fc 81       	ldd	r31, Y+4	; 0x04
     b24:	10 82       	st	Z, r1
	pxTopOfStack--;
     b26:	8b 81       	ldd	r24, Y+3	; 0x03
     b28:	9c 81       	ldd	r25, Y+4	; 0x04
     b2a:	01 97       	sbiw	r24, 0x01	; 1
     b2c:	9c 83       	std	Y+4, r25	; 0x04
     b2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b30:	eb 81       	ldd	r30, Y+3	; 0x03
     b32:	fc 81       	ldd	r31, Y+4	; 0x04
     b34:	80 e8       	ldi	r24, 0x80	; 128
     b36:	80 83       	st	Z, r24
	pxTopOfStack--;
     b38:	8b 81       	ldd	r24, Y+3	; 0x03
     b3a:	9c 81       	ldd	r25, Y+4	; 0x04
     b3c:	01 97       	sbiw	r24, 0x01	; 1
     b3e:	9c 83       	std	Y+4, r25	; 0x04
     b40:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     b42:	eb 81       	ldd	r30, Y+3	; 0x03
     b44:	fc 81       	ldd	r31, Y+4	; 0x04
     b46:	10 82       	st	Z, r1
	pxTopOfStack--;
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
     b4a:	9c 81       	ldd	r25, Y+4	; 0x04
     b4c:	01 97       	sbiw	r24, 0x01	; 1
     b4e:	9c 83       	std	Y+4, r25	; 0x04
     b50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     b52:	eb 81       	ldd	r30, Y+3	; 0x03
     b54:	fc 81       	ldd	r31, Y+4	; 0x04
     b56:	82 e0       	ldi	r24, 0x02	; 2
     b58:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5a:	8b 81       	ldd	r24, Y+3	; 0x03
     b5c:	9c 81       	ldd	r25, Y+4	; 0x04
     b5e:	01 97       	sbiw	r24, 0x01	; 1
     b60:	9c 83       	std	Y+4, r25	; 0x04
     b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     b64:	eb 81       	ldd	r30, Y+3	; 0x03
     b66:	fc 81       	ldd	r31, Y+4	; 0x04
     b68:	83 e0       	ldi	r24, 0x03	; 3
     b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	9c 81       	ldd	r25, Y+4	; 0x04
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	9c 83       	std	Y+4, r25	; 0x04
     b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     b76:	eb 81       	ldd	r30, Y+3	; 0x03
     b78:	fc 81       	ldd	r31, Y+4	; 0x04
     b7a:	84 e0       	ldi	r24, 0x04	; 4
     b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b7e:	8b 81       	ldd	r24, Y+3	; 0x03
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	9c 83       	std	Y+4, r25	; 0x04
     b86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     b88:	eb 81       	ldd	r30, Y+3	; 0x03
     b8a:	fc 81       	ldd	r31, Y+4	; 0x04
     b8c:	85 e0       	ldi	r24, 0x05	; 5
     b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	9c 81       	ldd	r25, Y+4	; 0x04
     b94:	01 97       	sbiw	r24, 0x01	; 1
     b96:	9c 83       	std	Y+4, r25	; 0x04
     b98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     b9a:	eb 81       	ldd	r30, Y+3	; 0x03
     b9c:	fc 81       	ldd	r31, Y+4	; 0x04
     b9e:	86 e0       	ldi	r24, 0x06	; 6
     ba0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba2:	8b 81       	ldd	r24, Y+3	; 0x03
     ba4:	9c 81       	ldd	r25, Y+4	; 0x04
     ba6:	01 97       	sbiw	r24, 0x01	; 1
     ba8:	9c 83       	std	Y+4, r25	; 0x04
     baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     bac:	eb 81       	ldd	r30, Y+3	; 0x03
     bae:	fc 81       	ldd	r31, Y+4	; 0x04
     bb0:	87 e0       	ldi	r24, 0x07	; 7
     bb2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb4:	8b 81       	ldd	r24, Y+3	; 0x03
     bb6:	9c 81       	ldd	r25, Y+4	; 0x04
     bb8:	01 97       	sbiw	r24, 0x01	; 1
     bba:	9c 83       	std	Y+4, r25	; 0x04
     bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     bbe:	eb 81       	ldd	r30, Y+3	; 0x03
     bc0:	fc 81       	ldd	r31, Y+4	; 0x04
     bc2:	88 e0       	ldi	r24, 0x08	; 8
     bc4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	01 97       	sbiw	r24, 0x01	; 1
     bcc:	9c 83       	std	Y+4, r25	; 0x04
     bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     bd0:	eb 81       	ldd	r30, Y+3	; 0x03
     bd2:	fc 81       	ldd	r31, Y+4	; 0x04
     bd4:	89 e0       	ldi	r24, 0x09	; 9
     bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd8:	8b 81       	ldd	r24, Y+3	; 0x03
     bda:	9c 81       	ldd	r25, Y+4	; 0x04
     bdc:	01 97       	sbiw	r24, 0x01	; 1
     bde:	9c 83       	std	Y+4, r25	; 0x04
     be0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     be2:	eb 81       	ldd	r30, Y+3	; 0x03
     be4:	fc 81       	ldd	r31, Y+4	; 0x04
     be6:	80 e1       	ldi	r24, 0x10	; 16
     be8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bea:	8b 81       	ldd	r24, Y+3	; 0x03
     bec:	9c 81       	ldd	r25, Y+4	; 0x04
     bee:	01 97       	sbiw	r24, 0x01	; 1
     bf0:	9c 83       	std	Y+4, r25	; 0x04
     bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     bf4:	eb 81       	ldd	r30, Y+3	; 0x03
     bf6:	fc 81       	ldd	r31, Y+4	; 0x04
     bf8:	81 e1       	ldi	r24, 0x11	; 17
     bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	9c 81       	ldd	r25, Y+4	; 0x04
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	9c 83       	std	Y+4, r25	; 0x04
     c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     c06:	eb 81       	ldd	r30, Y+3	; 0x03
     c08:	fc 81       	ldd	r31, Y+4	; 0x04
     c0a:	82 e1       	ldi	r24, 0x12	; 18
     c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	9c 83       	std	Y+4, r25	; 0x04
     c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     c18:	eb 81       	ldd	r30, Y+3	; 0x03
     c1a:	fc 81       	ldd	r31, Y+4	; 0x04
     c1c:	83 e1       	ldi	r24, 0x13	; 19
     c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     c2a:	eb 81       	ldd	r30, Y+3	; 0x03
     c2c:	fc 81       	ldd	r31, Y+4	; 0x04
     c2e:	84 e1       	ldi	r24, 0x14	; 20
     c30:	80 83       	st	Z, r24
	pxTopOfStack--;
     c32:	8b 81       	ldd	r24, Y+3	; 0x03
     c34:	9c 81       	ldd	r25, Y+4	; 0x04
     c36:	01 97       	sbiw	r24, 0x01	; 1
     c38:	9c 83       	std	Y+4, r25	; 0x04
     c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     c3c:	eb 81       	ldd	r30, Y+3	; 0x03
     c3e:	fc 81       	ldd	r31, Y+4	; 0x04
     c40:	85 e1       	ldi	r24, 0x15	; 21
     c42:	80 83       	st	Z, r24
	pxTopOfStack--;
     c44:	8b 81       	ldd	r24, Y+3	; 0x03
     c46:	9c 81       	ldd	r25, Y+4	; 0x04
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	9c 83       	std	Y+4, r25	; 0x04
     c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     c4e:	eb 81       	ldd	r30, Y+3	; 0x03
     c50:	fc 81       	ldd	r31, Y+4	; 0x04
     c52:	86 e1       	ldi	r24, 0x16	; 22
     c54:	80 83       	st	Z, r24
	pxTopOfStack--;
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	9c 83       	std	Y+4, r25	; 0x04
     c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c60:	eb 81       	ldd	r30, Y+3	; 0x03
     c62:	fc 81       	ldd	r31, Y+4	; 0x04
     c64:	87 e1       	ldi	r24, 0x17	; 23
     c66:	80 83       	st	Z, r24
	pxTopOfStack--;
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	01 97       	sbiw	r24, 0x01	; 1
     c6e:	9c 83       	std	Y+4, r25	; 0x04
     c70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c72:	eb 81       	ldd	r30, Y+3	; 0x03
     c74:	fc 81       	ldd	r31, Y+4	; 0x04
     c76:	88 e1       	ldi	r24, 0x18	; 24
     c78:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7a:	8b 81       	ldd	r24, Y+3	; 0x03
     c7c:	9c 81       	ldd	r25, Y+4	; 0x04
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	9c 83       	std	Y+4, r25	; 0x04
     c82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	89 e1       	ldi	r24, 0x19	; 25
     c8a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	9c 83       	std	Y+4, r25	; 0x04
     c94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c96:	eb 81       	ldd	r30, Y+3	; 0x03
     c98:	fc 81       	ldd	r31, Y+4	; 0x04
     c9a:	80 e2       	ldi	r24, 0x20	; 32
     c9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	9c 83       	std	Y+4, r25	; 0x04
     ca6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     ca8:	eb 81       	ldd	r30, Y+3	; 0x03
     caa:	fc 81       	ldd	r31, Y+4	; 0x04
     cac:	81 e2       	ldi	r24, 0x21	; 33
     cae:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	01 97       	sbiw	r24, 0x01	; 1
     cb6:	9c 83       	std	Y+4, r25	; 0x04
     cb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     cba:	eb 81       	ldd	r30, Y+3	; 0x03
     cbc:	fc 81       	ldd	r31, Y+4	; 0x04
     cbe:	82 e2       	ldi	r24, 0x22	; 34
     cc0:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	9c 81       	ldd	r25, Y+4	; 0x04
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	9c 83       	std	Y+4, r25	; 0x04
     cca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     ccc:	eb 81       	ldd	r30, Y+3	; 0x03
     cce:	fc 81       	ldd	r31, Y+4	; 0x04
     cd0:	83 e2       	ldi	r24, 0x23	; 35
     cd2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd4:	8b 81       	ldd	r24, Y+3	; 0x03
     cd6:	9c 81       	ldd	r25, Y+4	; 0x04
     cd8:	01 97       	sbiw	r24, 0x01	; 1
     cda:	9c 83       	std	Y+4, r25	; 0x04
     cdc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     cde:	8f 81       	ldd	r24, Y+7	; 0x07
     ce0:	98 85       	ldd	r25, Y+8	; 0x08
     ce2:	9a 83       	std	Y+2, r25	; 0x02
     ce4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
     ce8:	eb 81       	ldd	r30, Y+3	; 0x03
     cea:	fc 81       	ldd	r31, Y+4	; 0x04
     cec:	80 83       	st	Z, r24
	pxTopOfStack--;
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	01 97       	sbiw	r24, 0x01	; 1
     cf4:	9c 83       	std	Y+4, r25	; 0x04
     cf6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     cf8:	89 81       	ldd	r24, Y+1	; 0x01
     cfa:	9a 81       	ldd	r25, Y+2	; 0x02
     cfc:	89 2f       	mov	r24, r25
     cfe:	99 27       	eor	r25, r25
     d00:	9a 83       	std	Y+2, r25	; 0x02
     d02:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d04:	89 81       	ldd	r24, Y+1	; 0x01
     d06:	eb 81       	ldd	r30, Y+3	; 0x03
     d08:	fc 81       	ldd	r31, Y+4	; 0x04
     d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	86 e2       	ldi	r24, 0x26	; 38
     d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	87 e2       	ldi	r24, 0x27	; 39
     d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d30:	8b 81       	ldd	r24, Y+3	; 0x03
     d32:	9c 81       	ldd	r25, Y+4	; 0x04
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	9c 83       	std	Y+4, r25	; 0x04
     d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	88 e2       	ldi	r24, 0x28	; 40
     d40:	80 83       	st	Z, r24
	pxTopOfStack--;
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	9c 81       	ldd	r25, Y+4	; 0x04
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     d4c:	eb 81       	ldd	r30, Y+3	; 0x03
     d4e:	fc 81       	ldd	r31, Y+4	; 0x04
     d50:	89 e2       	ldi	r24, 0x29	; 41
     d52:	80 83       	st	Z, r24
	pxTopOfStack--;
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     d5e:	eb 81       	ldd	r30, Y+3	; 0x03
     d60:	fc 81       	ldd	r31, Y+4	; 0x04
     d62:	80 e3       	ldi	r24, 0x30	; 48
     d64:	80 83       	st	Z, r24
	pxTopOfStack--;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     d70:	eb 81       	ldd	r30, Y+3	; 0x03
     d72:	fc 81       	ldd	r31, Y+4	; 0x04
     d74:	81 e3       	ldi	r24, 0x31	; 49
     d76:	80 83       	st	Z, r24
	pxTopOfStack--;
     d78:	8b 81       	ldd	r24, Y+3	; 0x03
     d7a:	9c 81       	ldd	r25, Y+4	; 0x04
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	9c 83       	std	Y+4, r25	; 0x04
     d80:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d82:	8b 81       	ldd	r24, Y+3	; 0x03
     d84:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d86:	28 96       	adiw	r28, 0x08	; 8
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	cf 91       	pop	r28
     d94:	df 91       	pop	r29
     d96:	08 95       	ret

00000d98 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     d98:	df 93       	push	r29
     d9a:	cf 93       	push	r28
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     da0:	0e 94 bc 07 	call	0xf78	; 0xf78 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     da4:	a0 91 02 03 	lds	r26, 0x0302
     da8:	b0 91 03 03 	lds	r27, 0x0303
     dac:	cd 91       	ld	r28, X+
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	dd 91       	ld	r29, X+
     db2:	de bf       	out	0x3e, r29	; 62
     db4:	ff 91       	pop	r31
     db6:	ef 91       	pop	r30
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	bf 91       	pop	r27
     dbe:	af 91       	pop	r26
     dc0:	9f 91       	pop	r25
     dc2:	8f 91       	pop	r24
     dc4:	7f 91       	pop	r23
     dc6:	6f 91       	pop	r22
     dc8:	5f 91       	pop	r21
     dca:	4f 91       	pop	r20
     dcc:	3f 91       	pop	r19
     dce:	2f 91       	pop	r18
     dd0:	1f 91       	pop	r17
     dd2:	0f 91       	pop	r16
     dd4:	ff 90       	pop	r15
     dd6:	ef 90       	pop	r14
     dd8:	df 90       	pop	r13
     dda:	cf 90       	pop	r12
     ddc:	bf 90       	pop	r11
     dde:	af 90       	pop	r10
     de0:	9f 90       	pop	r9
     de2:	8f 90       	pop	r8
     de4:	7f 90       	pop	r7
     de6:	6f 90       	pop	r6
     de8:	5f 90       	pop	r5
     dea:	4f 90       	pop	r4
     dec:	3f 90       	pop	r3
     dee:	2f 90       	pop	r2
     df0:	1f 90       	pop	r1
     df2:	0f 90       	pop	r0
     df4:	0f be       	out	0x3f, r0	; 63
     df6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     df8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     dfa:	81 e0       	ldi	r24, 0x01	; 1
}
     dfc:	cf 91       	pop	r28
     dfe:	df 91       	pop	r29
     e00:	08 95       	ret

00000e02 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     e02:	df 93       	push	r29
     e04:	cf 93       	push	r28
     e06:	cd b7       	in	r28, 0x3d	; 61
     e08:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     e0a:	cf 91       	pop	r28
     e0c:	df 91       	pop	r29
     e0e:	08 95       	ret

00000e10 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e10:	0f 92       	push	r0
     e12:	0f b6       	in	r0, 0x3f	; 63
     e14:	f8 94       	cli
     e16:	0f 92       	push	r0
     e18:	1f 92       	push	r1
     e1a:	11 24       	eor	r1, r1
     e1c:	2f 92       	push	r2
     e1e:	3f 92       	push	r3
     e20:	4f 92       	push	r4
     e22:	5f 92       	push	r5
     e24:	6f 92       	push	r6
     e26:	7f 92       	push	r7
     e28:	8f 92       	push	r8
     e2a:	9f 92       	push	r9
     e2c:	af 92       	push	r10
     e2e:	bf 92       	push	r11
     e30:	cf 92       	push	r12
     e32:	df 92       	push	r13
     e34:	ef 92       	push	r14
     e36:	ff 92       	push	r15
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	2f 93       	push	r18
     e3e:	3f 93       	push	r19
     e40:	4f 93       	push	r20
     e42:	5f 93       	push	r21
     e44:	6f 93       	push	r22
     e46:	7f 93       	push	r23
     e48:	8f 93       	push	r24
     e4a:	9f 93       	push	r25
     e4c:	af 93       	push	r26
     e4e:	bf 93       	push	r27
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	ef 93       	push	r30
     e56:	ff 93       	push	r31
     e58:	a0 91 02 03 	lds	r26, 0x0302
     e5c:	b0 91 03 03 	lds	r27, 0x0303
     e60:	0d b6       	in	r0, 0x3d	; 61
     e62:	0d 92       	st	X+, r0
     e64:	0e b6       	in	r0, 0x3e	; 62
     e66:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e68:	0e 94 78 10 	call	0x20f0	; 0x20f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e6c:	a0 91 02 03 	lds	r26, 0x0302
     e70:	b0 91 03 03 	lds	r27, 0x0303
     e74:	cd 91       	ld	r28, X+
     e76:	cd bf       	out	0x3d, r28	; 61
     e78:	dd 91       	ld	r29, X+
     e7a:	de bf       	out	0x3e, r29	; 62
     e7c:	ff 91       	pop	r31
     e7e:	ef 91       	pop	r30
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	bf 91       	pop	r27
     e86:	af 91       	pop	r26
     e88:	9f 91       	pop	r25
     e8a:	8f 91       	pop	r24
     e8c:	7f 91       	pop	r23
     e8e:	6f 91       	pop	r22
     e90:	5f 91       	pop	r21
     e92:	4f 91       	pop	r20
     e94:	3f 91       	pop	r19
     e96:	2f 91       	pop	r18
     e98:	1f 91       	pop	r17
     e9a:	0f 91       	pop	r16
     e9c:	ff 90       	pop	r15
     e9e:	ef 90       	pop	r14
     ea0:	df 90       	pop	r13
     ea2:	cf 90       	pop	r12
     ea4:	bf 90       	pop	r11
     ea6:	af 90       	pop	r10
     ea8:	9f 90       	pop	r9
     eaa:	8f 90       	pop	r8
     eac:	7f 90       	pop	r7
     eae:	6f 90       	pop	r6
     eb0:	5f 90       	pop	r5
     eb2:	4f 90       	pop	r4
     eb4:	3f 90       	pop	r3
     eb6:	2f 90       	pop	r2
     eb8:	1f 90       	pop	r1
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63
     ebe:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ec0:	08 95       	ret

00000ec2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ec2:	0f 92       	push	r0
     ec4:	0f b6       	in	r0, 0x3f	; 63
     ec6:	f8 94       	cli
     ec8:	0f 92       	push	r0
     eca:	1f 92       	push	r1
     ecc:	11 24       	eor	r1, r1
     ece:	2f 92       	push	r2
     ed0:	3f 92       	push	r3
     ed2:	4f 92       	push	r4
     ed4:	5f 92       	push	r5
     ed6:	6f 92       	push	r6
     ed8:	7f 92       	push	r7
     eda:	8f 92       	push	r8
     edc:	9f 92       	push	r9
     ede:	af 92       	push	r10
     ee0:	bf 92       	push	r11
     ee2:	cf 92       	push	r12
     ee4:	df 92       	push	r13
     ee6:	ef 92       	push	r14
     ee8:	ff 92       	push	r15
     eea:	0f 93       	push	r16
     eec:	1f 93       	push	r17
     eee:	2f 93       	push	r18
     ef0:	3f 93       	push	r19
     ef2:	4f 93       	push	r20
     ef4:	5f 93       	push	r21
     ef6:	6f 93       	push	r22
     ef8:	7f 93       	push	r23
     efa:	8f 93       	push	r24
     efc:	9f 93       	push	r25
     efe:	af 93       	push	r26
     f00:	bf 93       	push	r27
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
     f06:	ef 93       	push	r30
     f08:	ff 93       	push	r31
     f0a:	a0 91 02 03 	lds	r26, 0x0302
     f0e:	b0 91 03 03 	lds	r27, 0x0303
     f12:	0d b6       	in	r0, 0x3d	; 61
     f14:	0d 92       	st	X+, r0
     f16:	0e b6       	in	r0, 0x3e	; 62
     f18:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     f1a:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskIncrementTick>
	vTaskSwitchContext();
     f1e:	0e 94 78 10 	call	0x20f0	; 0x20f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f22:	a0 91 02 03 	lds	r26, 0x0302
     f26:	b0 91 03 03 	lds	r27, 0x0303
     f2a:	cd 91       	ld	r28, X+
     f2c:	cd bf       	out	0x3d, r28	; 61
     f2e:	dd 91       	ld	r29, X+
     f30:	de bf       	out	0x3e, r29	; 62
     f32:	ff 91       	pop	r31
     f34:	ef 91       	pop	r30
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	bf 91       	pop	r27
     f3c:	af 91       	pop	r26
     f3e:	9f 91       	pop	r25
     f40:	8f 91       	pop	r24
     f42:	7f 91       	pop	r23
     f44:	6f 91       	pop	r22
     f46:	5f 91       	pop	r21
     f48:	4f 91       	pop	r20
     f4a:	3f 91       	pop	r19
     f4c:	2f 91       	pop	r18
     f4e:	1f 91       	pop	r17
     f50:	0f 91       	pop	r16
     f52:	ff 90       	pop	r15
     f54:	ef 90       	pop	r14
     f56:	df 90       	pop	r13
     f58:	cf 90       	pop	r12
     f5a:	bf 90       	pop	r11
     f5c:	af 90       	pop	r10
     f5e:	9f 90       	pop	r9
     f60:	8f 90       	pop	r8
     f62:	7f 90       	pop	r7
     f64:	6f 90       	pop	r6
     f66:	5f 90       	pop	r5
     f68:	4f 90       	pop	r4
     f6a:	3f 90       	pop	r3
     f6c:	2f 90       	pop	r2
     f6e:	1f 90       	pop	r1
     f70:	0f 90       	pop	r0
     f72:	0f be       	out	0x3f, r0	; 63
     f74:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f76:	08 95       	ret

00000f78 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f78:	df 93       	push	r29
     f7a:	cf 93       	push	r28
     f7c:	00 d0       	rcall	.+0      	; 0xf7e <prvSetupTimerInterrupt+0x6>
     f7e:	00 d0       	rcall	.+0      	; 0xf80 <prvSetupTimerInterrupt+0x8>
     f80:	00 d0       	rcall	.+0      	; 0xf82 <prvSetupTimerInterrupt+0xa>
     f82:	cd b7       	in	r28, 0x3d	; 61
     f84:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f86:	80 ee       	ldi	r24, 0xE0	; 224
     f88:	9e e2       	ldi	r25, 0x2E	; 46
     f8a:	a0 e0       	ldi	r26, 0x00	; 0
     f8c:	b0 e0       	ldi	r27, 0x00	; 0
     f8e:	8b 83       	std	Y+3, r24	; 0x03
     f90:	9c 83       	std	Y+4, r25	; 0x04
     f92:	ad 83       	std	Y+5, r26	; 0x05
     f94:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f96:	8b 81       	ldd	r24, Y+3	; 0x03
     f98:	9c 81       	ldd	r25, Y+4	; 0x04
     f9a:	ad 81       	ldd	r26, Y+5	; 0x05
     f9c:	be 81       	ldd	r27, Y+6	; 0x06
     f9e:	68 94       	set
     fa0:	15 f8       	bld	r1, 5
     fa2:	b6 95       	lsr	r27
     fa4:	a7 95       	ror	r26
     fa6:	97 95       	ror	r25
     fa8:	87 95       	ror	r24
     faa:	16 94       	lsr	r1
     fac:	d1 f7       	brne	.-12     	; 0xfa2 <prvSetupTimerInterrupt+0x2a>
     fae:	8b 83       	std	Y+3, r24	; 0x03
     fb0:	9c 83       	std	Y+4, r25	; 0x04
     fb2:	ad 83       	std	Y+5, r26	; 0x05
     fb4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     fb6:	8b 81       	ldd	r24, Y+3	; 0x03
     fb8:	9c 81       	ldd	r25, Y+4	; 0x04
     fba:	ad 81       	ldd	r26, Y+5	; 0x05
     fbc:	be 81       	ldd	r27, Y+6	; 0x06
     fbe:	01 97       	sbiw	r24, 0x01	; 1
     fc0:	a1 09       	sbc	r26, r1
     fc2:	b1 09       	sbc	r27, r1
     fc4:	8b 83       	std	Y+3, r24	; 0x03
     fc6:	9c 83       	std	Y+4, r25	; 0x04
     fc8:	ad 83       	std	Y+5, r26	; 0x05
     fca:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fd0:	8b 81       	ldd	r24, Y+3	; 0x03
     fd2:	9c 81       	ldd	r25, Y+4	; 0x04
     fd4:	ad 81       	ldd	r26, Y+5	; 0x05
     fd6:	be 81       	ldd	r27, Y+6	; 0x06
     fd8:	89 2f       	mov	r24, r25
     fda:	9a 2f       	mov	r25, r26
     fdc:	ab 2f       	mov	r26, r27
     fde:	bb 27       	eor	r27, r27
     fe0:	8b 83       	std	Y+3, r24	; 0x03
     fe2:	9c 83       	std	Y+4, r25	; 0x04
     fe4:	ad 83       	std	Y+5, r26	; 0x05
     fe6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fe8:	8b 81       	ldd	r24, Y+3	; 0x03
     fea:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fec:	eb e4       	ldi	r30, 0x4B	; 75
     fee:	f0 e0       	ldi	r31, 0x00	; 0
     ff0:	8a 81       	ldd	r24, Y+2	; 0x02
     ff2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     ff4:	ea e4       	ldi	r30, 0x4A	; 74
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	89 81       	ldd	r24, Y+1	; 0x01
     ffa:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     ffc:	8b e0       	ldi	r24, 0x0B	; 11
     ffe:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1000:	ee e4       	ldi	r30, 0x4E	; 78
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	89 81       	ldd	r24, Y+1	; 0x01
    1006:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1008:	e9 e5       	ldi	r30, 0x59	; 89
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	80 81       	ld	r24, Z
    100e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1010:	89 81       	ldd	r24, Y+1	; 0x01
    1012:	80 61       	ori	r24, 0x10	; 16
    1014:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1016:	e9 e5       	ldi	r30, 0x59	; 89
    1018:	f0 e0       	ldi	r31, 0x00	; 0
    101a:	89 81       	ldd	r24, Y+1	; 0x01
    101c:	80 83       	st	Z, r24
}
    101e:	26 96       	adiw	r28, 0x06	; 6
    1020:	0f b6       	in	r0, 0x3f	; 63
    1022:	f8 94       	cli
    1024:	de bf       	out	0x3e, r29	; 62
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	cd bf       	out	0x3d, r28	; 61
    102a:	cf 91       	pop	r28
    102c:	df 91       	pop	r29
    102e:	08 95       	ret

00001030 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1030:	0e 94 61 07 	call	0xec2	; 0xec2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1034:	18 95       	reti

00001036 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1036:	df 93       	push	r29
    1038:	cf 93       	push	r28
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	28 97       	sbiw	r28, 0x08	; 8
    1040:	0f b6       	in	r0, 0x3f	; 63
    1042:	f8 94       	cli
    1044:	de bf       	out	0x3e, r29	; 62
    1046:	0f be       	out	0x3f, r0	; 63
    1048:	cd bf       	out	0x3d, r28	; 61
    104a:	8f 83       	std	Y+7, r24	; 0x07
    104c:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    104e:	1a 82       	std	Y+2, r1	; 0x02
    1050:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1052:	8f 81       	ldd	r24, Y+7	; 0x07
    1054:	88 23       	and	r24, r24
    1056:	09 f4       	brne	.+2      	; 0x105a <xQueueCreate+0x24>
    1058:	8c c0       	rjmp	.+280    	; 0x1172 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    105a:	8f e1       	ldi	r24, 0x1F	; 31
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	0e 94 a2 03 	call	0x744	; 0x744 <pvPortMalloc>
    1062:	9e 83       	std	Y+6, r25	; 0x06
    1064:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1066:	8d 81       	ldd	r24, Y+5	; 0x05
    1068:	9e 81       	ldd	r25, Y+6	; 0x06
    106a:	00 97       	sbiw	r24, 0x00	; 0
    106c:	09 f4       	brne	.+2      	; 0x1070 <xQueueCreate+0x3a>
    106e:	81 c0       	rjmp	.+258    	; 0x1172 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1070:	8f 81       	ldd	r24, Y+7	; 0x07
    1072:	28 2f       	mov	r18, r24
    1074:	30 e0       	ldi	r19, 0x00	; 0
    1076:	88 85       	ldd	r24, Y+8	; 0x08
    1078:	88 2f       	mov	r24, r24
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	ac 01       	movw	r20, r24
    107e:	24 9f       	mul	r18, r20
    1080:	c0 01       	movw	r24, r0
    1082:	25 9f       	mul	r18, r21
    1084:	90 0d       	add	r25, r0
    1086:	34 9f       	mul	r19, r20
    1088:	90 0d       	add	r25, r0
    108a:	11 24       	eor	r1, r1
    108c:	01 96       	adiw	r24, 0x01	; 1
    108e:	9c 83       	std	Y+4, r25	; 0x04
    1090:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1092:	8b 81       	ldd	r24, Y+3	; 0x03
    1094:	9c 81       	ldd	r25, Y+4	; 0x04
    1096:	0e 94 a2 03 	call	0x744	; 0x744 <pvPortMalloc>
    109a:	ed 81       	ldd	r30, Y+5	; 0x05
    109c:	fe 81       	ldd	r31, Y+6	; 0x06
    109e:	91 83       	std	Z+1, r25	; 0x01
    10a0:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    10a2:	ed 81       	ldd	r30, Y+5	; 0x05
    10a4:	fe 81       	ldd	r31, Y+6	; 0x06
    10a6:	80 81       	ld	r24, Z
    10a8:	91 81       	ldd	r25, Z+1	; 0x01
    10aa:	00 97       	sbiw	r24, 0x00	; 0
    10ac:	09 f4       	brne	.+2      	; 0x10b0 <xQueueCreate+0x7a>
    10ae:	5d c0       	rjmp	.+186    	; 0x116a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    10b0:	ed 81       	ldd	r30, Y+5	; 0x05
    10b2:	fe 81       	ldd	r31, Y+6	; 0x06
    10b4:	40 81       	ld	r20, Z
    10b6:	51 81       	ldd	r21, Z+1	; 0x01
    10b8:	8f 81       	ldd	r24, Y+7	; 0x07
    10ba:	28 2f       	mov	r18, r24
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	88 85       	ldd	r24, Y+8	; 0x08
    10c0:	88 2f       	mov	r24, r24
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	bc 01       	movw	r22, r24
    10c6:	26 9f       	mul	r18, r22
    10c8:	c0 01       	movw	r24, r0
    10ca:	27 9f       	mul	r18, r23
    10cc:	90 0d       	add	r25, r0
    10ce:	36 9f       	mul	r19, r22
    10d0:	90 0d       	add	r25, r0
    10d2:	11 24       	eor	r1, r1
    10d4:	84 0f       	add	r24, r20
    10d6:	95 1f       	adc	r25, r21
    10d8:	ed 81       	ldd	r30, Y+5	; 0x05
    10da:	fe 81       	ldd	r31, Y+6	; 0x06
    10dc:	93 83       	std	Z+3, r25	; 0x03
    10de:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    10e0:	ed 81       	ldd	r30, Y+5	; 0x05
    10e2:	fe 81       	ldd	r31, Y+6	; 0x06
    10e4:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    10e6:	ed 81       	ldd	r30, Y+5	; 0x05
    10e8:	fe 81       	ldd	r31, Y+6	; 0x06
    10ea:	80 81       	ld	r24, Z
    10ec:	91 81       	ldd	r25, Z+1	; 0x01
    10ee:	ed 81       	ldd	r30, Y+5	; 0x05
    10f0:	fe 81       	ldd	r31, Y+6	; 0x06
    10f2:	95 83       	std	Z+5, r25	; 0x05
    10f4:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    10f6:	ed 81       	ldd	r30, Y+5	; 0x05
    10f8:	fe 81       	ldd	r31, Y+6	; 0x06
    10fa:	40 81       	ld	r20, Z
    10fc:	51 81       	ldd	r21, Z+1	; 0x01
    10fe:	8f 81       	ldd	r24, Y+7	; 0x07
    1100:	88 2f       	mov	r24, r24
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	9c 01       	movw	r18, r24
    1106:	21 50       	subi	r18, 0x01	; 1
    1108:	30 40       	sbci	r19, 0x00	; 0
    110a:	88 85       	ldd	r24, Y+8	; 0x08
    110c:	88 2f       	mov	r24, r24
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	bc 01       	movw	r22, r24
    1112:	26 9f       	mul	r18, r22
    1114:	c0 01       	movw	r24, r0
    1116:	27 9f       	mul	r18, r23
    1118:	90 0d       	add	r25, r0
    111a:	36 9f       	mul	r19, r22
    111c:	90 0d       	add	r25, r0
    111e:	11 24       	eor	r1, r1
    1120:	84 0f       	add	r24, r20
    1122:	95 1f       	adc	r25, r21
    1124:	ed 81       	ldd	r30, Y+5	; 0x05
    1126:	fe 81       	ldd	r31, Y+6	; 0x06
    1128:	97 83       	std	Z+7, r25	; 0x07
    112a:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    112c:	ed 81       	ldd	r30, Y+5	; 0x05
    112e:	fe 81       	ldd	r31, Y+6	; 0x06
    1130:	8f 81       	ldd	r24, Y+7	; 0x07
    1132:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1134:	ed 81       	ldd	r30, Y+5	; 0x05
    1136:	fe 81       	ldd	r31, Y+6	; 0x06
    1138:	88 85       	ldd	r24, Y+8	; 0x08
    113a:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    113c:	ed 81       	ldd	r30, Y+5	; 0x05
    113e:	fe 81       	ldd	r31, Y+6	; 0x06
    1140:	8f ef       	ldi	r24, 0xFF	; 255
    1142:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1144:	ed 81       	ldd	r30, Y+5	; 0x05
    1146:	fe 81       	ldd	r31, Y+6	; 0x06
    1148:	8f ef       	ldi	r24, 0xFF	; 255
    114a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    114c:	8d 81       	ldd	r24, Y+5	; 0x05
    114e:	9e 81       	ldd	r25, Y+6	; 0x06
    1150:	08 96       	adiw	r24, 0x08	; 8
    1152:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1156:	8d 81       	ldd	r24, Y+5	; 0x05
    1158:	9e 81       	ldd	r25, Y+6	; 0x06
    115a:	41 96       	adiw	r24, 0x11	; 17
    115c:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1160:	8d 81       	ldd	r24, Y+5	; 0x05
    1162:	9e 81       	ldd	r25, Y+6	; 0x06
    1164:	9a 83       	std	Y+2, r25	; 0x02
    1166:	89 83       	std	Y+1, r24	; 0x01
    1168:	04 c0       	rjmp	.+8      	; 0x1172 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    116a:	8d 81       	ldd	r24, Y+5	; 0x05
    116c:	9e 81       	ldd	r25, Y+6	; 0x06
    116e:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1172:	89 81       	ldd	r24, Y+1	; 0x01
    1174:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1176:	28 96       	adiw	r28, 0x08	; 8
    1178:	0f b6       	in	r0, 0x3f	; 63
    117a:	f8 94       	cli
    117c:	de bf       	out	0x3e, r29	; 62
    117e:	0f be       	out	0x3f, r0	; 63
    1180:	cd bf       	out	0x3d, r28	; 61
    1182:	cf 91       	pop	r28
    1184:	df 91       	pop	r29
    1186:	08 95       	ret

00001188 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1188:	df 93       	push	r29
    118a:	cf 93       	push	r28
    118c:	cd b7       	in	r28, 0x3d	; 61
    118e:	de b7       	in	r29, 0x3e	; 62
    1190:	2c 97       	sbiw	r28, 0x0c	; 12
    1192:	0f b6       	in	r0, 0x3f	; 63
    1194:	f8 94       	cli
    1196:	de bf       	out	0x3e, r29	; 62
    1198:	0f be       	out	0x3f, r0	; 63
    119a:	cd bf       	out	0x3d, r28	; 61
    119c:	9e 83       	std	Y+6, r25	; 0x06
    119e:	8d 83       	std	Y+5, r24	; 0x05
    11a0:	78 87       	std	Y+8, r23	; 0x08
    11a2:	6f 83       	std	Y+7, r22	; 0x07
    11a4:	5a 87       	std	Y+10, r21	; 0x0a
    11a6:	49 87       	std	Y+9, r20	; 0x09
    11a8:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    11aa:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    11b2:	ed 81       	ldd	r30, Y+5	; 0x05
    11b4:	fe 81       	ldd	r31, Y+6	; 0x06
    11b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    11b8:	ed 81       	ldd	r30, Y+5	; 0x05
    11ba:	fe 81       	ldd	r31, Y+6	; 0x06
    11bc:	83 8d       	ldd	r24, Z+27	; 0x1b
    11be:	98 17       	cp	r25, r24
    11c0:	d8 f4       	brcc	.+54     	; 0x11f8 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11c2:	8d 81       	ldd	r24, Y+5	; 0x05
    11c4:	9e 81       	ldd	r25, Y+6	; 0x06
    11c6:	2f 81       	ldd	r18, Y+7	; 0x07
    11c8:	38 85       	ldd	r19, Y+8	; 0x08
    11ca:	b9 01       	movw	r22, r18
    11cc:	4b 85       	ldd	r20, Y+11	; 0x0b
    11ce:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11d2:	ed 81       	ldd	r30, Y+5	; 0x05
    11d4:	fe 81       	ldd	r31, Y+6	; 0x06
    11d6:	81 89       	ldd	r24, Z+17	; 0x11
    11d8:	88 23       	and	r24, r24
    11da:	49 f0       	breq	.+18     	; 0x11ee <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    11dc:	8d 81       	ldd	r24, Y+5	; 0x05
    11de:	9e 81       	ldd	r25, Y+6	; 0x06
    11e0:	41 96       	adiw	r24, 0x11	; 17
    11e2:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    11e6:	81 30       	cpi	r24, 0x01	; 1
    11e8:	11 f4       	brne	.+4      	; 0x11ee <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    11ea:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    11ee:	0f 90       	pop	r0
    11f0:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	8c 87       	std	Y+12, r24	; 0x0c
    11f6:	5c c0       	rjmp	.+184    	; 0x12b0 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    11f8:	89 85       	ldd	r24, Y+9	; 0x09
    11fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    11fc:	00 97       	sbiw	r24, 0x00	; 0
    11fe:	21 f4       	brne	.+8      	; 0x1208 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1200:	0f 90       	pop	r0
    1202:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1204:	1c 86       	std	Y+12, r1	; 0x0c
    1206:	54 c0       	rjmp	.+168    	; 0x12b0 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1208:	89 81       	ldd	r24, Y+1	; 0x01
    120a:	88 23       	and	r24, r24
    120c:	31 f4       	brne	.+12     	; 0x121a <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    120e:	ce 01       	movw	r24, r28
    1210:	02 96       	adiw	r24, 0x02	; 2
    1212:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    121a:	0f 90       	pop	r0
    121c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    121e:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	f8 94       	cli
    1226:	0f 92       	push	r0
    1228:	ed 81       	ldd	r30, Y+5	; 0x05
    122a:	fe 81       	ldd	r31, Y+6	; 0x06
    122c:	85 8d       	ldd	r24, Z+29	; 0x1d
    122e:	8f 3f       	cpi	r24, 0xFF	; 255
    1230:	19 f4       	brne	.+6      	; 0x1238 <xQueueGenericSend+0xb0>
    1232:	ed 81       	ldd	r30, Y+5	; 0x05
    1234:	fe 81       	ldd	r31, Y+6	; 0x06
    1236:	15 8e       	std	Z+29, r1	; 0x1d
    1238:	ed 81       	ldd	r30, Y+5	; 0x05
    123a:	fe 81       	ldd	r31, Y+6	; 0x06
    123c:	86 8d       	ldd	r24, Z+30	; 0x1e
    123e:	8f 3f       	cpi	r24, 0xFF	; 255
    1240:	19 f4       	brne	.+6      	; 0x1248 <xQueueGenericSend+0xc0>
    1242:	ed 81       	ldd	r30, Y+5	; 0x05
    1244:	fe 81       	ldd	r31, Y+6	; 0x06
    1246:	16 8e       	std	Z+30, r1	; 0x1e
    1248:	0f 90       	pop	r0
    124a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    124c:	ce 01       	movw	r24, r28
    124e:	02 96       	adiw	r24, 0x02	; 2
    1250:	9e 01       	movw	r18, r28
    1252:	27 5f       	subi	r18, 0xF7	; 247
    1254:	3f 4f       	sbci	r19, 0xFF	; 255
    1256:	b9 01       	movw	r22, r18
    1258:	0e 94 95 11 	call	0x232a	; 0x232a <xTaskCheckForTimeOut>
    125c:	88 23       	and	r24, r24
    125e:	09 f5       	brne	.+66     	; 0x12a2 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1260:	8d 81       	ldd	r24, Y+5	; 0x05
    1262:	9e 81       	ldd	r25, Y+6	; 0x06
    1264:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <prvIsQueueFull>
    1268:	88 23       	and	r24, r24
    126a:	a1 f0       	breq	.+40     	; 0x1294 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    126c:	8d 81       	ldd	r24, Y+5	; 0x05
    126e:	9e 81       	ldd	r25, Y+6	; 0x06
    1270:	08 96       	adiw	r24, 0x08	; 8
    1272:	29 85       	ldd	r18, Y+9	; 0x09
    1274:	3a 85       	ldd	r19, Y+10	; 0x0a
    1276:	b9 01       	movw	r22, r18
    1278:	0e 94 de 10 	call	0x21bc	; 0x21bc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    127c:	8d 81       	ldd	r24, Y+5	; 0x05
    127e:	9e 81       	ldd	r25, Y+6	; 0x06
    1280:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1284:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
    1288:	88 23       	and	r24, r24
    128a:	09 f0       	breq	.+2      	; 0x128e <xQueueGenericSend+0x106>
    128c:	8f cf       	rjmp	.-226    	; 0x11ac <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    128e:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
    1292:	8c cf       	rjmp	.-232    	; 0x11ac <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1294:	8d 81       	ldd	r24, Y+5	; 0x05
    1296:	9e 81       	ldd	r25, Y+6	; 0x06
    1298:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    129c:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
    12a0:	85 cf       	rjmp	.-246    	; 0x11ac <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    12a2:	8d 81       	ldd	r24, Y+5	; 0x05
    12a4:	9e 81       	ldd	r25, Y+6	; 0x06
    12a6:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12aa:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    12ae:	1c 86       	std	Y+12, r1	; 0x0c
    12b0:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    12b2:	2c 96       	adiw	r28, 0x0c	; 12
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	f8 94       	cli
    12b8:	de bf       	out	0x3e, r29	; 62
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	cd bf       	out	0x3d, r28	; 61
    12be:	cf 91       	pop	r28
    12c0:	df 91       	pop	r29
    12c2:	08 95       	ret

000012c4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    12c4:	df 93       	push	r29
    12c6:	cf 93       	push	r28
    12c8:	cd b7       	in	r28, 0x3d	; 61
    12ca:	de b7       	in	r29, 0x3e	; 62
    12cc:	29 97       	sbiw	r28, 0x09	; 9
    12ce:	0f b6       	in	r0, 0x3f	; 63
    12d0:	f8 94       	cli
    12d2:	de bf       	out	0x3e, r29	; 62
    12d4:	0f be       	out	0x3f, r0	; 63
    12d6:	cd bf       	out	0x3d, r28	; 61
    12d8:	9c 83       	std	Y+4, r25	; 0x04
    12da:	8b 83       	std	Y+3, r24	; 0x03
    12dc:	7e 83       	std	Y+6, r23	; 0x06
    12de:	6d 83       	std	Y+5, r22	; 0x05
    12e0:	58 87       	std	Y+8, r21	; 0x08
    12e2:	4f 83       	std	Y+7, r20	; 0x07
    12e4:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    12e6:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    12e8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ea:	fc 81       	ldd	r31, Y+4	; 0x04
    12ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    12ee:	eb 81       	ldd	r30, Y+3	; 0x03
    12f0:	fc 81       	ldd	r31, Y+4	; 0x04
    12f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    12f4:	98 17       	cp	r25, r24
    12f6:	40 f5       	brcc	.+80     	; 0x1348 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	9c 81       	ldd	r25, Y+4	; 0x04
    12fc:	2d 81       	ldd	r18, Y+5	; 0x05
    12fe:	3e 81       	ldd	r19, Y+6	; 0x06
    1300:	b9 01       	movw	r22, r18
    1302:	49 85       	ldd	r20, Y+9	; 0x09
    1304:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1308:	eb 81       	ldd	r30, Y+3	; 0x03
    130a:	fc 81       	ldd	r31, Y+4	; 0x04
    130c:	86 8d       	ldd	r24, Z+30	; 0x1e
    130e:	8f 3f       	cpi	r24, 0xFF	; 255
    1310:	89 f4       	brne	.+34     	; 0x1334 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1312:	eb 81       	ldd	r30, Y+3	; 0x03
    1314:	fc 81       	ldd	r31, Y+4	; 0x04
    1316:	81 89       	ldd	r24, Z+17	; 0x11
    1318:	88 23       	and	r24, r24
    131a:	99 f0       	breq	.+38     	; 0x1342 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    131c:	8b 81       	ldd	r24, Y+3	; 0x03
    131e:	9c 81       	ldd	r25, Y+4	; 0x04
    1320:	41 96       	adiw	r24, 0x11	; 17
    1322:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    1326:	88 23       	and	r24, r24
    1328:	61 f0       	breq	.+24     	; 0x1342 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    132a:	ef 81       	ldd	r30, Y+7	; 0x07
    132c:	f8 85       	ldd	r31, Y+8	; 0x08
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	80 83       	st	Z, r24
    1332:	07 c0       	rjmp	.+14     	; 0x1342 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1334:	eb 81       	ldd	r30, Y+3	; 0x03
    1336:	fc 81       	ldd	r31, Y+4	; 0x04
    1338:	86 8d       	ldd	r24, Z+30	; 0x1e
    133a:	8f 5f       	subi	r24, 0xFF	; 255
    133c:	eb 81       	ldd	r30, Y+3	; 0x03
    133e:	fc 81       	ldd	r31, Y+4	; 0x04
    1340:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1342:	81 e0       	ldi	r24, 0x01	; 1
    1344:	8a 83       	std	Y+2, r24	; 0x02
    1346:	01 c0       	rjmp	.+2      	; 0x134a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1348:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    134a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    134c:	29 96       	adiw	r28, 0x09	; 9
    134e:	0f b6       	in	r0, 0x3f	; 63
    1350:	f8 94       	cli
    1352:	de bf       	out	0x3e, r29	; 62
    1354:	0f be       	out	0x3f, r0	; 63
    1356:	cd bf       	out	0x3d, r28	; 61
    1358:	cf 91       	pop	r28
    135a:	df 91       	pop	r29
    135c:	08 95       	ret

0000135e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    135e:	df 93       	push	r29
    1360:	cf 93       	push	r28
    1362:	cd b7       	in	r28, 0x3d	; 61
    1364:	de b7       	in	r29, 0x3e	; 62
    1366:	2e 97       	sbiw	r28, 0x0e	; 14
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	de bf       	out	0x3e, r29	; 62
    136e:	0f be       	out	0x3f, r0	; 63
    1370:	cd bf       	out	0x3d, r28	; 61
    1372:	98 87       	std	Y+8, r25	; 0x08
    1374:	8f 83       	std	Y+7, r24	; 0x07
    1376:	7a 87       	std	Y+10, r23	; 0x0a
    1378:	69 87       	std	Y+9, r22	; 0x09
    137a:	5c 87       	std	Y+12, r21	; 0x0c
    137c:	4b 87       	std	Y+11, r20	; 0x0b
    137e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1380:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1382:	0f b6       	in	r0, 0x3f	; 63
    1384:	f8 94       	cli
    1386:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1388:	ef 81       	ldd	r30, Y+7	; 0x07
    138a:	f8 85       	ldd	r31, Y+8	; 0x08
    138c:	82 8d       	ldd	r24, Z+26	; 0x1a
    138e:	88 23       	and	r24, r24
    1390:	09 f4       	brne	.+2      	; 0x1394 <xQueueGenericReceive+0x36>
    1392:	3f c0       	rjmp	.+126    	; 0x1412 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1394:	ef 81       	ldd	r30, Y+7	; 0x07
    1396:	f8 85       	ldd	r31, Y+8	; 0x08
    1398:	86 81       	ldd	r24, Z+6	; 0x06
    139a:	97 81       	ldd	r25, Z+7	; 0x07
    139c:	9a 83       	std	Y+2, r25	; 0x02
    139e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    13a0:	8f 81       	ldd	r24, Y+7	; 0x07
    13a2:	98 85       	ldd	r25, Y+8	; 0x08
    13a4:	29 85       	ldd	r18, Y+9	; 0x09
    13a6:	3a 85       	ldd	r19, Y+10	; 0x0a
    13a8:	b9 01       	movw	r22, r18
    13aa:	0e 94 94 0b 	call	0x1728	; 0x1728 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    13ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    13b0:	88 23       	and	r24, r24
    13b2:	b1 f4       	brne	.+44     	; 0x13e0 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    13b4:	ef 81       	ldd	r30, Y+7	; 0x07
    13b6:	f8 85       	ldd	r31, Y+8	; 0x08
    13b8:	82 8d       	ldd	r24, Z+26	; 0x1a
    13ba:	81 50       	subi	r24, 0x01	; 1
    13bc:	ef 81       	ldd	r30, Y+7	; 0x07
    13be:	f8 85       	ldd	r31, Y+8	; 0x08
    13c0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13c2:	ef 81       	ldd	r30, Y+7	; 0x07
    13c4:	f8 85       	ldd	r31, Y+8	; 0x08
    13c6:	80 85       	ldd	r24, Z+8	; 0x08
    13c8:	88 23       	and	r24, r24
    13ca:	f1 f0       	breq	.+60     	; 0x1408 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13cc:	8f 81       	ldd	r24, Y+7	; 0x07
    13ce:	98 85       	ldd	r25, Y+8	; 0x08
    13d0:	08 96       	adiw	r24, 0x08	; 8
    13d2:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    13d6:	81 30       	cpi	r24, 0x01	; 1
    13d8:	b9 f4       	brne	.+46     	; 0x1408 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    13da:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
    13de:	14 c0       	rjmp	.+40     	; 0x1408 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    13e0:	ef 81       	ldd	r30, Y+7	; 0x07
    13e2:	f8 85       	ldd	r31, Y+8	; 0x08
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	9a 81       	ldd	r25, Y+2	; 0x02
    13e8:	97 83       	std	Z+7, r25	; 0x07
    13ea:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ec:	ef 81       	ldd	r30, Y+7	; 0x07
    13ee:	f8 85       	ldd	r31, Y+8	; 0x08
    13f0:	81 89       	ldd	r24, Z+17	; 0x11
    13f2:	88 23       	and	r24, r24
    13f4:	49 f0       	breq	.+18     	; 0x1408 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13f6:	8f 81       	ldd	r24, Y+7	; 0x07
    13f8:	98 85       	ldd	r25, Y+8	; 0x08
    13fa:	41 96       	adiw	r24, 0x11	; 17
    13fc:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    1400:	88 23       	and	r24, r24
    1402:	11 f0       	breq	.+4      	; 0x1408 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1404:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1408:	0f 90       	pop	r0
    140a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	8e 87       	std	Y+14, r24	; 0x0e
    1410:	5c c0       	rjmp	.+184    	; 0x14ca <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1412:	8b 85       	ldd	r24, Y+11	; 0x0b
    1414:	9c 85       	ldd	r25, Y+12	; 0x0c
    1416:	00 97       	sbiw	r24, 0x00	; 0
    1418:	21 f4       	brne	.+8      	; 0x1422 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    141e:	1e 86       	std	Y+14, r1	; 0x0e
    1420:	54 c0       	rjmp	.+168    	; 0x14ca <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1422:	8b 81       	ldd	r24, Y+3	; 0x03
    1424:	88 23       	and	r24, r24
    1426:	31 f4       	brne	.+12     	; 0x1434 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1428:	ce 01       	movw	r24, r28
    142a:	04 96       	adiw	r24, 0x04	; 4
    142c:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1430:	81 e0       	ldi	r24, 0x01	; 1
    1432:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1434:	0f 90       	pop	r0
    1436:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1438:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	0f 92       	push	r0
    1442:	ef 81       	ldd	r30, Y+7	; 0x07
    1444:	f8 85       	ldd	r31, Y+8	; 0x08
    1446:	85 8d       	ldd	r24, Z+29	; 0x1d
    1448:	8f 3f       	cpi	r24, 0xFF	; 255
    144a:	19 f4       	brne	.+6      	; 0x1452 <xQueueGenericReceive+0xf4>
    144c:	ef 81       	ldd	r30, Y+7	; 0x07
    144e:	f8 85       	ldd	r31, Y+8	; 0x08
    1450:	15 8e       	std	Z+29, r1	; 0x1d
    1452:	ef 81       	ldd	r30, Y+7	; 0x07
    1454:	f8 85       	ldd	r31, Y+8	; 0x08
    1456:	86 8d       	ldd	r24, Z+30	; 0x1e
    1458:	8f 3f       	cpi	r24, 0xFF	; 255
    145a:	19 f4       	brne	.+6      	; 0x1462 <xQueueGenericReceive+0x104>
    145c:	ef 81       	ldd	r30, Y+7	; 0x07
    145e:	f8 85       	ldd	r31, Y+8	; 0x08
    1460:	16 8e       	std	Z+30, r1	; 0x1e
    1462:	0f 90       	pop	r0
    1464:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1466:	ce 01       	movw	r24, r28
    1468:	04 96       	adiw	r24, 0x04	; 4
    146a:	9e 01       	movw	r18, r28
    146c:	25 5f       	subi	r18, 0xF5	; 245
    146e:	3f 4f       	sbci	r19, 0xFF	; 255
    1470:	b9 01       	movw	r22, r18
    1472:	0e 94 95 11 	call	0x232a	; 0x232a <xTaskCheckForTimeOut>
    1476:	88 23       	and	r24, r24
    1478:	09 f5       	brne	.+66     	; 0x14bc <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    147a:	8f 81       	ldd	r24, Y+7	; 0x07
    147c:	98 85       	ldd	r25, Y+8	; 0x08
    147e:	0e 94 30 0c 	call	0x1860	; 0x1860 <prvIsQueueEmpty>
    1482:	88 23       	and	r24, r24
    1484:	a1 f0       	breq	.+40     	; 0x14ae <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1486:	8f 81       	ldd	r24, Y+7	; 0x07
    1488:	98 85       	ldd	r25, Y+8	; 0x08
    148a:	41 96       	adiw	r24, 0x11	; 17
    148c:	2b 85       	ldd	r18, Y+11	; 0x0b
    148e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1490:	b9 01       	movw	r22, r18
    1492:	0e 94 de 10 	call	0x21bc	; 0x21bc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1496:	8f 81       	ldd	r24, Y+7	; 0x07
    1498:	98 85       	ldd	r25, Y+8	; 0x08
    149a:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    149e:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
    14a2:	88 23       	and	r24, r24
    14a4:	09 f0       	breq	.+2      	; 0x14a8 <xQueueGenericReceive+0x14a>
    14a6:	6d cf       	rjmp	.-294    	; 0x1382 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    14a8:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
    14ac:	6a cf       	rjmp	.-300    	; 0x1382 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14ae:	8f 81       	ldd	r24, Y+7	; 0x07
    14b0:	98 85       	ldd	r25, Y+8	; 0x08
    14b2:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14b6:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
    14ba:	63 cf       	rjmp	.-314    	; 0x1382 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    14bc:	8f 81       	ldd	r24, Y+7	; 0x07
    14be:	98 85       	ldd	r25, Y+8	; 0x08
    14c0:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14c4:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    14c8:	1e 86       	std	Y+14, r1	; 0x0e
    14ca:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    14cc:	2e 96       	adiw	r28, 0x0e	; 14
    14ce:	0f b6       	in	r0, 0x3f	; 63
    14d0:	f8 94       	cli
    14d2:	de bf       	out	0x3e, r29	; 62
    14d4:	0f be       	out	0x3f, r0	; 63
    14d6:	cd bf       	out	0x3d, r28	; 61
    14d8:	cf 91       	pop	r28
    14da:	df 91       	pop	r29
    14dc:	08 95       	ret

000014de <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    14de:	df 93       	push	r29
    14e0:	cf 93       	push	r28
    14e2:	cd b7       	in	r28, 0x3d	; 61
    14e4:	de b7       	in	r29, 0x3e	; 62
    14e6:	28 97       	sbiw	r28, 0x08	; 8
    14e8:	0f b6       	in	r0, 0x3f	; 63
    14ea:	f8 94       	cli
    14ec:	de bf       	out	0x3e, r29	; 62
    14ee:	0f be       	out	0x3f, r0	; 63
    14f0:	cd bf       	out	0x3d, r28	; 61
    14f2:	9c 83       	std	Y+4, r25	; 0x04
    14f4:	8b 83       	std	Y+3, r24	; 0x03
    14f6:	7e 83       	std	Y+6, r23	; 0x06
    14f8:	6d 83       	std	Y+5, r22	; 0x05
    14fa:	58 87       	std	Y+8, r21	; 0x08
    14fc:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14fe:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1500:	eb 81       	ldd	r30, Y+3	; 0x03
    1502:	fc 81       	ldd	r31, Y+4	; 0x04
    1504:	82 8d       	ldd	r24, Z+26	; 0x1a
    1506:	88 23       	and	r24, r24
    1508:	71 f1       	breq	.+92     	; 0x1566 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    150a:	8b 81       	ldd	r24, Y+3	; 0x03
    150c:	9c 81       	ldd	r25, Y+4	; 0x04
    150e:	2d 81       	ldd	r18, Y+5	; 0x05
    1510:	3e 81       	ldd	r19, Y+6	; 0x06
    1512:	b9 01       	movw	r22, r18
    1514:	0e 94 94 0b 	call	0x1728	; 0x1728 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1518:	eb 81       	ldd	r30, Y+3	; 0x03
    151a:	fc 81       	ldd	r31, Y+4	; 0x04
    151c:	82 8d       	ldd	r24, Z+26	; 0x1a
    151e:	81 50       	subi	r24, 0x01	; 1
    1520:	eb 81       	ldd	r30, Y+3	; 0x03
    1522:	fc 81       	ldd	r31, Y+4	; 0x04
    1524:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1526:	eb 81       	ldd	r30, Y+3	; 0x03
    1528:	fc 81       	ldd	r31, Y+4	; 0x04
    152a:	85 8d       	ldd	r24, Z+29	; 0x1d
    152c:	8f 3f       	cpi	r24, 0xFF	; 255
    152e:	89 f4       	brne	.+34     	; 0x1552 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1530:	eb 81       	ldd	r30, Y+3	; 0x03
    1532:	fc 81       	ldd	r31, Y+4	; 0x04
    1534:	80 85       	ldd	r24, Z+8	; 0x08
    1536:	88 23       	and	r24, r24
    1538:	99 f0       	breq	.+38     	; 0x1560 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    153a:	8b 81       	ldd	r24, Y+3	; 0x03
    153c:	9c 81       	ldd	r25, Y+4	; 0x04
    153e:	08 96       	adiw	r24, 0x08	; 8
    1540:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    1544:	88 23       	and	r24, r24
    1546:	61 f0       	breq	.+24     	; 0x1560 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1548:	ef 81       	ldd	r30, Y+7	; 0x07
    154a:	f8 85       	ldd	r31, Y+8	; 0x08
    154c:	81 e0       	ldi	r24, 0x01	; 1
    154e:	80 83       	st	Z, r24
    1550:	07 c0       	rjmp	.+14     	; 0x1560 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1552:	eb 81       	ldd	r30, Y+3	; 0x03
    1554:	fc 81       	ldd	r31, Y+4	; 0x04
    1556:	85 8d       	ldd	r24, Z+29	; 0x1d
    1558:	8f 5f       	subi	r24, 0xFF	; 255
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1560:	81 e0       	ldi	r24, 0x01	; 1
    1562:	8a 83       	std	Y+2, r24	; 0x02
    1564:	01 c0       	rjmp	.+2      	; 0x1568 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1566:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1568:	8a 81       	ldd	r24, Y+2	; 0x02
}
    156a:	28 96       	adiw	r28, 0x08	; 8
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	de bf       	out	0x3e, r29	; 62
    1572:	0f be       	out	0x3f, r0	; 63
    1574:	cd bf       	out	0x3d, r28	; 61
    1576:	cf 91       	pop	r28
    1578:	df 91       	pop	r29
    157a:	08 95       	ret

0000157c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    157c:	df 93       	push	r29
    157e:	cf 93       	push	r28
    1580:	00 d0       	rcall	.+0      	; 0x1582 <uxQueueMessagesWaiting+0x6>
    1582:	0f 92       	push	r0
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
    1588:	9b 83       	std	Y+3, r25	; 0x03
    158a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    158c:	0f b6       	in	r0, 0x3f	; 63
    158e:	f8 94       	cli
    1590:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1592:	ea 81       	ldd	r30, Y+2	; 0x02
    1594:	fb 81       	ldd	r31, Y+3	; 0x03
    1596:	82 8d       	ldd	r24, Z+26	; 0x1a
    1598:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    159a:	0f 90       	pop	r0
    159c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    159e:	89 81       	ldd	r24, Y+1	; 0x01
}
    15a0:	0f 90       	pop	r0
    15a2:	0f 90       	pop	r0
    15a4:	0f 90       	pop	r0
    15a6:	cf 91       	pop	r28
    15a8:	df 91       	pop	r29
    15aa:	08 95       	ret

000015ac <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    15ac:	df 93       	push	r29
    15ae:	cf 93       	push	r28
    15b0:	00 d0       	rcall	.+0      	; 0x15b2 <uxQueueMessagesWaitingFromISR+0x6>
    15b2:	0f 92       	push	r0
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
    15b8:	9b 83       	std	Y+3, r25	; 0x03
    15ba:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    15bc:	ea 81       	ldd	r30, Y+2	; 0x02
    15be:	fb 81       	ldd	r31, Y+3	; 0x03
    15c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    15c2:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    15c4:	89 81       	ldd	r24, Y+1	; 0x01
}
    15c6:	0f 90       	pop	r0
    15c8:	0f 90       	pop	r0
    15ca:	0f 90       	pop	r0
    15cc:	cf 91       	pop	r28
    15ce:	df 91       	pop	r29
    15d0:	08 95       	ret

000015d2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    15d2:	df 93       	push	r29
    15d4:	cf 93       	push	r28
    15d6:	00 d0       	rcall	.+0      	; 0x15d8 <vQueueDelete+0x6>
    15d8:	cd b7       	in	r28, 0x3d	; 61
    15da:	de b7       	in	r29, 0x3e	; 62
    15dc:	9a 83       	std	Y+2, r25	; 0x02
    15de:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    15e0:	e9 81       	ldd	r30, Y+1	; 0x01
    15e2:	fa 81       	ldd	r31, Y+2	; 0x02
    15e4:	80 81       	ld	r24, Z
    15e6:	91 81       	ldd	r25, Z+1	; 0x01
    15e8:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vPortFree>
	vPortFree( pxQueue );
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	9a 81       	ldd	r25, Y+2	; 0x02
    15f0:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vPortFree>
}
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	cf 91       	pop	r28
    15fa:	df 91       	pop	r29
    15fc:	08 95       	ret

000015fe <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    15fe:	df 93       	push	r29
    1600:	cf 93       	push	r28
    1602:	00 d0       	rcall	.+0      	; 0x1604 <prvCopyDataToQueue+0x6>
    1604:	00 d0       	rcall	.+0      	; 0x1606 <prvCopyDataToQueue+0x8>
    1606:	0f 92       	push	r0
    1608:	cd b7       	in	r28, 0x3d	; 61
    160a:	de b7       	in	r29, 0x3e	; 62
    160c:	9a 83       	std	Y+2, r25	; 0x02
    160e:	89 83       	std	Y+1, r24	; 0x01
    1610:	7c 83       	std	Y+4, r23	; 0x04
    1612:	6b 83       	std	Y+3, r22	; 0x03
    1614:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1616:	e9 81       	ldd	r30, Y+1	; 0x01
    1618:	fa 81       	ldd	r31, Y+2	; 0x02
    161a:	84 8d       	ldd	r24, Z+28	; 0x1c
    161c:	88 23       	and	r24, r24
    161e:	09 f4       	brne	.+2      	; 0x1622 <prvCopyDataToQueue+0x24>
    1620:	74 c0       	rjmp	.+232    	; 0x170a <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1622:	8d 81       	ldd	r24, Y+5	; 0x05
    1624:	88 23       	and	r24, r24
    1626:	99 f5       	brne	.+102    	; 0x168e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1628:	e9 81       	ldd	r30, Y+1	; 0x01
    162a:	fa 81       	ldd	r31, Y+2	; 0x02
    162c:	64 81       	ldd	r22, Z+4	; 0x04
    162e:	75 81       	ldd	r23, Z+5	; 0x05
    1630:	e9 81       	ldd	r30, Y+1	; 0x01
    1632:	fa 81       	ldd	r31, Y+2	; 0x02
    1634:	84 8d       	ldd	r24, Z+28	; 0x1c
    1636:	48 2f       	mov	r20, r24
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	2b 81       	ldd	r18, Y+3	; 0x03
    163c:	3c 81       	ldd	r19, Y+4	; 0x04
    163e:	cb 01       	movw	r24, r22
    1640:	b9 01       	movw	r22, r18
    1642:	0e 94 87 13 	call	0x270e	; 0x270e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1646:	e9 81       	ldd	r30, Y+1	; 0x01
    1648:	fa 81       	ldd	r31, Y+2	; 0x02
    164a:	24 81       	ldd	r18, Z+4	; 0x04
    164c:	35 81       	ldd	r19, Z+5	; 0x05
    164e:	e9 81       	ldd	r30, Y+1	; 0x01
    1650:	fa 81       	ldd	r31, Y+2	; 0x02
    1652:	84 8d       	ldd	r24, Z+28	; 0x1c
    1654:	88 2f       	mov	r24, r24
    1656:	90 e0       	ldi	r25, 0x00	; 0
    1658:	82 0f       	add	r24, r18
    165a:	93 1f       	adc	r25, r19
    165c:	e9 81       	ldd	r30, Y+1	; 0x01
    165e:	fa 81       	ldd	r31, Y+2	; 0x02
    1660:	95 83       	std	Z+5, r25	; 0x05
    1662:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1664:	e9 81       	ldd	r30, Y+1	; 0x01
    1666:	fa 81       	ldd	r31, Y+2	; 0x02
    1668:	24 81       	ldd	r18, Z+4	; 0x04
    166a:	35 81       	ldd	r19, Z+5	; 0x05
    166c:	e9 81       	ldd	r30, Y+1	; 0x01
    166e:	fa 81       	ldd	r31, Y+2	; 0x02
    1670:	82 81       	ldd	r24, Z+2	; 0x02
    1672:	93 81       	ldd	r25, Z+3	; 0x03
    1674:	28 17       	cp	r18, r24
    1676:	39 07       	cpc	r19, r25
    1678:	08 f4       	brcc	.+2      	; 0x167c <prvCopyDataToQueue+0x7e>
    167a:	47 c0       	rjmp	.+142    	; 0x170a <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    167c:	e9 81       	ldd	r30, Y+1	; 0x01
    167e:	fa 81       	ldd	r31, Y+2	; 0x02
    1680:	80 81       	ld	r24, Z
    1682:	91 81       	ldd	r25, Z+1	; 0x01
    1684:	e9 81       	ldd	r30, Y+1	; 0x01
    1686:	fa 81       	ldd	r31, Y+2	; 0x02
    1688:	95 83       	std	Z+5, r25	; 0x05
    168a:	84 83       	std	Z+4, r24	; 0x04
    168c:	3e c0       	rjmp	.+124    	; 0x170a <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    168e:	e9 81       	ldd	r30, Y+1	; 0x01
    1690:	fa 81       	ldd	r31, Y+2	; 0x02
    1692:	66 81       	ldd	r22, Z+6	; 0x06
    1694:	77 81       	ldd	r23, Z+7	; 0x07
    1696:	e9 81       	ldd	r30, Y+1	; 0x01
    1698:	fa 81       	ldd	r31, Y+2	; 0x02
    169a:	84 8d       	ldd	r24, Z+28	; 0x1c
    169c:	48 2f       	mov	r20, r24
    169e:	50 e0       	ldi	r21, 0x00	; 0
    16a0:	2b 81       	ldd	r18, Y+3	; 0x03
    16a2:	3c 81       	ldd	r19, Y+4	; 0x04
    16a4:	cb 01       	movw	r24, r22
    16a6:	b9 01       	movw	r22, r18
    16a8:	0e 94 87 13 	call	0x270e	; 0x270e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    16ac:	e9 81       	ldd	r30, Y+1	; 0x01
    16ae:	fa 81       	ldd	r31, Y+2	; 0x02
    16b0:	26 81       	ldd	r18, Z+6	; 0x06
    16b2:	37 81       	ldd	r19, Z+7	; 0x07
    16b4:	e9 81       	ldd	r30, Y+1	; 0x01
    16b6:	fa 81       	ldd	r31, Y+2	; 0x02
    16b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    16ba:	88 2f       	mov	r24, r24
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	90 95       	com	r25
    16c0:	81 95       	neg	r24
    16c2:	9f 4f       	sbci	r25, 0xFF	; 255
    16c4:	82 0f       	add	r24, r18
    16c6:	93 1f       	adc	r25, r19
    16c8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ca:	fa 81       	ldd	r31, Y+2	; 0x02
    16cc:	97 83       	std	Z+7, r25	; 0x07
    16ce:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    16d0:	e9 81       	ldd	r30, Y+1	; 0x01
    16d2:	fa 81       	ldd	r31, Y+2	; 0x02
    16d4:	26 81       	ldd	r18, Z+6	; 0x06
    16d6:	37 81       	ldd	r19, Z+7	; 0x07
    16d8:	e9 81       	ldd	r30, Y+1	; 0x01
    16da:	fa 81       	ldd	r31, Y+2	; 0x02
    16dc:	80 81       	ld	r24, Z
    16de:	91 81       	ldd	r25, Z+1	; 0x01
    16e0:	28 17       	cp	r18, r24
    16e2:	39 07       	cpc	r19, r25
    16e4:	90 f4       	brcc	.+36     	; 0x170a <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16e6:	e9 81       	ldd	r30, Y+1	; 0x01
    16e8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ea:	22 81       	ldd	r18, Z+2	; 0x02
    16ec:	33 81       	ldd	r19, Z+3	; 0x03
    16ee:	e9 81       	ldd	r30, Y+1	; 0x01
    16f0:	fa 81       	ldd	r31, Y+2	; 0x02
    16f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    16f4:	88 2f       	mov	r24, r24
    16f6:	90 e0       	ldi	r25, 0x00	; 0
    16f8:	90 95       	com	r25
    16fa:	81 95       	neg	r24
    16fc:	9f 4f       	sbci	r25, 0xFF	; 255
    16fe:	82 0f       	add	r24, r18
    1700:	93 1f       	adc	r25, r19
    1702:	e9 81       	ldd	r30, Y+1	; 0x01
    1704:	fa 81       	ldd	r31, Y+2	; 0x02
    1706:	97 83       	std	Z+7, r25	; 0x07
    1708:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    170a:	e9 81       	ldd	r30, Y+1	; 0x01
    170c:	fa 81       	ldd	r31, Y+2	; 0x02
    170e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1710:	8f 5f       	subi	r24, 0xFF	; 255
    1712:	e9 81       	ldd	r30, Y+1	; 0x01
    1714:	fa 81       	ldd	r31, Y+2	; 0x02
    1716:	82 8f       	std	Z+26, r24	; 0x1a
}
    1718:	0f 90       	pop	r0
    171a:	0f 90       	pop	r0
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	cf 91       	pop	r28
    1724:	df 91       	pop	r29
    1726:	08 95       	ret

00001728 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1728:	df 93       	push	r29
    172a:	cf 93       	push	r28
    172c:	00 d0       	rcall	.+0      	; 0x172e <prvCopyDataFromQueue+0x6>
    172e:	00 d0       	rcall	.+0      	; 0x1730 <prvCopyDataFromQueue+0x8>
    1730:	cd b7       	in	r28, 0x3d	; 61
    1732:	de b7       	in	r29, 0x3e	; 62
    1734:	9a 83       	std	Y+2, r25	; 0x02
    1736:	89 83       	std	Y+1, r24	; 0x01
    1738:	7c 83       	std	Y+4, r23	; 0x04
    173a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    173c:	e9 81       	ldd	r30, Y+1	; 0x01
    173e:	fa 81       	ldd	r31, Y+2	; 0x02
    1740:	80 81       	ld	r24, Z
    1742:	91 81       	ldd	r25, Z+1	; 0x01
    1744:	00 97       	sbiw	r24, 0x00	; 0
    1746:	89 f1       	breq	.+98     	; 0x17aa <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1748:	e9 81       	ldd	r30, Y+1	; 0x01
    174a:	fa 81       	ldd	r31, Y+2	; 0x02
    174c:	26 81       	ldd	r18, Z+6	; 0x06
    174e:	37 81       	ldd	r19, Z+7	; 0x07
    1750:	e9 81       	ldd	r30, Y+1	; 0x01
    1752:	fa 81       	ldd	r31, Y+2	; 0x02
    1754:	84 8d       	ldd	r24, Z+28	; 0x1c
    1756:	88 2f       	mov	r24, r24
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	82 0f       	add	r24, r18
    175c:	93 1f       	adc	r25, r19
    175e:	e9 81       	ldd	r30, Y+1	; 0x01
    1760:	fa 81       	ldd	r31, Y+2	; 0x02
    1762:	97 83       	std	Z+7, r25	; 0x07
    1764:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1766:	e9 81       	ldd	r30, Y+1	; 0x01
    1768:	fa 81       	ldd	r31, Y+2	; 0x02
    176a:	26 81       	ldd	r18, Z+6	; 0x06
    176c:	37 81       	ldd	r19, Z+7	; 0x07
    176e:	e9 81       	ldd	r30, Y+1	; 0x01
    1770:	fa 81       	ldd	r31, Y+2	; 0x02
    1772:	82 81       	ldd	r24, Z+2	; 0x02
    1774:	93 81       	ldd	r25, Z+3	; 0x03
    1776:	28 17       	cp	r18, r24
    1778:	39 07       	cpc	r19, r25
    177a:	40 f0       	brcs	.+16     	; 0x178c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    177c:	e9 81       	ldd	r30, Y+1	; 0x01
    177e:	fa 81       	ldd	r31, Y+2	; 0x02
    1780:	80 81       	ld	r24, Z
    1782:	91 81       	ldd	r25, Z+1	; 0x01
    1784:	e9 81       	ldd	r30, Y+1	; 0x01
    1786:	fa 81       	ldd	r31, Y+2	; 0x02
    1788:	97 83       	std	Z+7, r25	; 0x07
    178a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    178c:	e9 81       	ldd	r30, Y+1	; 0x01
    178e:	fa 81       	ldd	r31, Y+2	; 0x02
    1790:	46 81       	ldd	r20, Z+6	; 0x06
    1792:	57 81       	ldd	r21, Z+7	; 0x07
    1794:	e9 81       	ldd	r30, Y+1	; 0x01
    1796:	fa 81       	ldd	r31, Y+2	; 0x02
    1798:	84 8d       	ldd	r24, Z+28	; 0x1c
    179a:	28 2f       	mov	r18, r24
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	8b 81       	ldd	r24, Y+3	; 0x03
    17a0:	9c 81       	ldd	r25, Y+4	; 0x04
    17a2:	ba 01       	movw	r22, r20
    17a4:	a9 01       	movw	r20, r18
    17a6:	0e 94 87 13 	call	0x270e	; 0x270e <memcpy>
	}
}
    17aa:	0f 90       	pop	r0
    17ac:	0f 90       	pop	r0
    17ae:	0f 90       	pop	r0
    17b0:	0f 90       	pop	r0
    17b2:	cf 91       	pop	r28
    17b4:	df 91       	pop	r29
    17b6:	08 95       	ret

000017b8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    17b8:	df 93       	push	r29
    17ba:	cf 93       	push	r28
    17bc:	00 d0       	rcall	.+0      	; 0x17be <prvUnlockQueue+0x6>
    17be:	cd b7       	in	r28, 0x3d	; 61
    17c0:	de b7       	in	r29, 0x3e	; 62
    17c2:	9a 83       	std	Y+2, r25	; 0x02
    17c4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	f8 94       	cli
    17ca:	0f 92       	push	r0
    17cc:	15 c0       	rjmp	.+42     	; 0x17f8 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ce:	e9 81       	ldd	r30, Y+1	; 0x01
    17d0:	fa 81       	ldd	r31, Y+2	; 0x02
    17d2:	81 89       	ldd	r24, Z+17	; 0x11
    17d4:	88 23       	and	r24, r24
    17d6:	a9 f0       	breq	.+42     	; 0x1802 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17d8:	89 81       	ldd	r24, Y+1	; 0x01
    17da:	9a 81       	ldd	r25, Y+2	; 0x02
    17dc:	41 96       	adiw	r24, 0x11	; 17
    17de:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    17e2:	88 23       	and	r24, r24
    17e4:	11 f0       	breq	.+4      	; 0x17ea <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    17e6:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    17ea:	e9 81       	ldd	r30, Y+1	; 0x01
    17ec:	fa 81       	ldd	r31, Y+2	; 0x02
    17ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    17f0:	81 50       	subi	r24, 0x01	; 1
    17f2:	e9 81       	ldd	r30, Y+1	; 0x01
    17f4:	fa 81       	ldd	r31, Y+2	; 0x02
    17f6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17f8:	e9 81       	ldd	r30, Y+1	; 0x01
    17fa:	fa 81       	ldd	r31, Y+2	; 0x02
    17fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    17fe:	18 16       	cp	r1, r24
    1800:	34 f3       	brlt	.-52     	; 0x17ce <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1802:	e9 81       	ldd	r30, Y+1	; 0x01
    1804:	fa 81       	ldd	r31, Y+2	; 0x02
    1806:	8f ef       	ldi	r24, 0xFF	; 255
    1808:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    180a:	0f 90       	pop	r0
    180c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    180e:	0f b6       	in	r0, 0x3f	; 63
    1810:	f8 94       	cli
    1812:	0f 92       	push	r0
    1814:	15 c0       	rjmp	.+42     	; 0x1840 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1816:	e9 81       	ldd	r30, Y+1	; 0x01
    1818:	fa 81       	ldd	r31, Y+2	; 0x02
    181a:	80 85       	ldd	r24, Z+8	; 0x08
    181c:	88 23       	and	r24, r24
    181e:	a9 f0       	breq	.+42     	; 0x184a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1820:	89 81       	ldd	r24, Y+1	; 0x01
    1822:	9a 81       	ldd	r25, Y+2	; 0x02
    1824:	08 96       	adiw	r24, 0x08	; 8
    1826:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskRemoveFromEventList>
    182a:	88 23       	and	r24, r24
    182c:	11 f0       	breq	.+4      	; 0x1832 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    182e:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1832:	e9 81       	ldd	r30, Y+1	; 0x01
    1834:	fa 81       	ldd	r31, Y+2	; 0x02
    1836:	85 8d       	ldd	r24, Z+29	; 0x1d
    1838:	81 50       	subi	r24, 0x01	; 1
    183a:	e9 81       	ldd	r30, Y+1	; 0x01
    183c:	fa 81       	ldd	r31, Y+2	; 0x02
    183e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1840:	e9 81       	ldd	r30, Y+1	; 0x01
    1842:	fa 81       	ldd	r31, Y+2	; 0x02
    1844:	85 8d       	ldd	r24, Z+29	; 0x1d
    1846:	18 16       	cp	r1, r24
    1848:	34 f3       	brlt	.-52     	; 0x1816 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    184a:	e9 81       	ldd	r30, Y+1	; 0x01
    184c:	fa 81       	ldd	r31, Y+2	; 0x02
    184e:	8f ef       	ldi	r24, 0xFF	; 255
    1850:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1852:	0f 90       	pop	r0
    1854:	0f be       	out	0x3f, r0	; 63
}
    1856:	0f 90       	pop	r0
    1858:	0f 90       	pop	r0
    185a:	cf 91       	pop	r28
    185c:	df 91       	pop	r29
    185e:	08 95       	ret

00001860 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1860:	df 93       	push	r29
    1862:	cf 93       	push	r28
    1864:	00 d0       	rcall	.+0      	; 0x1866 <prvIsQueueEmpty+0x6>
    1866:	0f 92       	push	r0
    1868:	cd b7       	in	r28, 0x3d	; 61
    186a:	de b7       	in	r29, 0x3e	; 62
    186c:	9b 83       	std	Y+3, r25	; 0x03
    186e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1870:	0f b6       	in	r0, 0x3f	; 63
    1872:	f8 94       	cli
    1874:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1876:	ea 81       	ldd	r30, Y+2	; 0x02
    1878:	fb 81       	ldd	r31, Y+3	; 0x03
    187a:	82 8d       	ldd	r24, Z+26	; 0x1a
    187c:	19 82       	std	Y+1, r1	; 0x01
    187e:	88 23       	and	r24, r24
    1880:	11 f4       	brne	.+4      	; 0x1886 <prvIsQueueEmpty+0x26>
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    188a:	89 81       	ldd	r24, Y+1	; 0x01
}
    188c:	0f 90       	pop	r0
    188e:	0f 90       	pop	r0
    1890:	0f 90       	pop	r0
    1892:	cf 91       	pop	r28
    1894:	df 91       	pop	r29
    1896:	08 95       	ret

00001898 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1898:	df 93       	push	r29
    189a:	cf 93       	push	r28
    189c:	00 d0       	rcall	.+0      	; 0x189e <xQueueIsQueueEmptyFromISR+0x6>
    189e:	0f 92       	push	r0
    18a0:	cd b7       	in	r28, 0x3d	; 61
    18a2:	de b7       	in	r29, 0x3e	; 62
    18a4:	9b 83       	std	Y+3, r25	; 0x03
    18a6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18a8:	ea 81       	ldd	r30, Y+2	; 0x02
    18aa:	fb 81       	ldd	r31, Y+3	; 0x03
    18ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ae:	19 82       	std	Y+1, r1	; 0x01
    18b0:	88 23       	and	r24, r24
    18b2:	11 f4       	brne	.+4      	; 0x18b8 <xQueueIsQueueEmptyFromISR+0x20>
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    18b8:	89 81       	ldd	r24, Y+1	; 0x01
}
    18ba:	0f 90       	pop	r0
    18bc:	0f 90       	pop	r0
    18be:	0f 90       	pop	r0
    18c0:	cf 91       	pop	r28
    18c2:	df 91       	pop	r29
    18c4:	08 95       	ret

000018c6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    18c6:	df 93       	push	r29
    18c8:	cf 93       	push	r28
    18ca:	00 d0       	rcall	.+0      	; 0x18cc <prvIsQueueFull+0x6>
    18cc:	0f 92       	push	r0
    18ce:	cd b7       	in	r28, 0x3d	; 61
    18d0:	de b7       	in	r29, 0x3e	; 62
    18d2:	9b 83       	std	Y+3, r25	; 0x03
    18d4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18d6:	0f b6       	in	r0, 0x3f	; 63
    18d8:	f8 94       	cli
    18da:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18dc:	ea 81       	ldd	r30, Y+2	; 0x02
    18de:	fb 81       	ldd	r31, Y+3	; 0x03
    18e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    18e2:	ea 81       	ldd	r30, Y+2	; 0x02
    18e4:	fb 81       	ldd	r31, Y+3	; 0x03
    18e6:	83 8d       	ldd	r24, Z+27	; 0x1b
    18e8:	19 82       	std	Y+1, r1	; 0x01
    18ea:	98 17       	cp	r25, r24
    18ec:	11 f4       	brne	.+4      	; 0x18f2 <prvIsQueueFull+0x2c>
    18ee:	81 e0       	ldi	r24, 0x01	; 1
    18f0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    18f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    18f8:	0f 90       	pop	r0
    18fa:	0f 90       	pop	r0
    18fc:	0f 90       	pop	r0
    18fe:	cf 91       	pop	r28
    1900:	df 91       	pop	r29
    1902:	08 95       	ret

00001904 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1904:	df 93       	push	r29
    1906:	cf 93       	push	r28
    1908:	00 d0       	rcall	.+0      	; 0x190a <xQueueIsQueueFullFromISR+0x6>
    190a:	0f 92       	push	r0
    190c:	cd b7       	in	r28, 0x3d	; 61
    190e:	de b7       	in	r29, 0x3e	; 62
    1910:	9b 83       	std	Y+3, r25	; 0x03
    1912:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1914:	ea 81       	ldd	r30, Y+2	; 0x02
    1916:	fb 81       	ldd	r31, Y+3	; 0x03
    1918:	92 8d       	ldd	r25, Z+26	; 0x1a
    191a:	ea 81       	ldd	r30, Y+2	; 0x02
    191c:	fb 81       	ldd	r31, Y+3	; 0x03
    191e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1920:	19 82       	std	Y+1, r1	; 0x01
    1922:	98 17       	cp	r25, r24
    1924:	11 f4       	brne	.+4      	; 0x192a <xQueueIsQueueFullFromISR+0x26>
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    192a:	89 81       	ldd	r24, Y+1	; 0x01
}
    192c:	0f 90       	pop	r0
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	cf 91       	pop	r28
    1934:	df 91       	pop	r29
    1936:	08 95       	ret

00001938 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1938:	af 92       	push	r10
    193a:	bf 92       	push	r11
    193c:	cf 92       	push	r12
    193e:	df 92       	push	r13
    1940:	ef 92       	push	r14
    1942:	ff 92       	push	r15
    1944:	0f 93       	push	r16
    1946:	1f 93       	push	r17
    1948:	df 93       	push	r29
    194a:	cf 93       	push	r28
    194c:	cd b7       	in	r28, 0x3d	; 61
    194e:	de b7       	in	r29, 0x3e	; 62
    1950:	64 97       	sbiw	r28, 0x14	; 20
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	f8 94       	cli
    1956:	de bf       	out	0x3e, r29	; 62
    1958:	0f be       	out	0x3f, r0	; 63
    195a:	cd bf       	out	0x3d, r28	; 61
    195c:	9f 83       	std	Y+7, r25	; 0x07
    195e:	8e 83       	std	Y+6, r24	; 0x06
    1960:	79 87       	std	Y+9, r23	; 0x09
    1962:	68 87       	std	Y+8, r22	; 0x08
    1964:	5b 87       	std	Y+11, r21	; 0x0b
    1966:	4a 87       	std	Y+10, r20	; 0x0a
    1968:	3d 87       	std	Y+13, r19	; 0x0d
    196a:	2c 87       	std	Y+12, r18	; 0x0c
    196c:	0e 87       	std	Y+14, r16	; 0x0e
    196e:	f8 8a       	std	Y+16, r15	; 0x10
    1970:	ef 86       	std	Y+15, r14	; 0x0f
    1972:	da 8a       	std	Y+18, r13	; 0x12
    1974:	c9 8a       	std	Y+17, r12	; 0x11
    1976:	bc 8a       	std	Y+20, r11	; 0x14
    1978:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    197a:	8a 85       	ldd	r24, Y+10	; 0x0a
    197c:	9b 85       	ldd	r25, Y+11	; 0x0b
    197e:	29 89       	ldd	r18, Y+17	; 0x11
    1980:	3a 89       	ldd	r19, Y+18	; 0x12
    1982:	b9 01       	movw	r22, r18
    1984:	0e 94 21 13 	call	0x2642	; 0x2642 <prvAllocateTCBAndStack>
    1988:	9c 83       	std	Y+4, r25	; 0x04
    198a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    198c:	8b 81       	ldd	r24, Y+3	; 0x03
    198e:	9c 81       	ldd	r25, Y+4	; 0x04
    1990:	00 97       	sbiw	r24, 0x00	; 0
    1992:	09 f4       	brne	.+2      	; 0x1996 <xTaskGenericCreate+0x5e>
    1994:	99 c0       	rjmp	.+306    	; 0x1ac8 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1996:	eb 81       	ldd	r30, Y+3	; 0x03
    1998:	fc 81       	ldd	r31, Y+4	; 0x04
    199a:	27 89       	ldd	r18, Z+23	; 0x17
    199c:	30 8d       	ldd	r19, Z+24	; 0x18
    199e:	8a 85       	ldd	r24, Y+10	; 0x0a
    19a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    19a2:	01 97       	sbiw	r24, 0x01	; 1
    19a4:	82 0f       	add	r24, r18
    19a6:	93 1f       	adc	r25, r19
    19a8:	9a 83       	std	Y+2, r25	; 0x02
    19aa:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    19ac:	8b 81       	ldd	r24, Y+3	; 0x03
    19ae:	9c 81       	ldd	r25, Y+4	; 0x04
    19b0:	28 85       	ldd	r18, Y+8	; 0x08
    19b2:	39 85       	ldd	r19, Y+9	; 0x09
    19b4:	eb 89       	ldd	r30, Y+19	; 0x13
    19b6:	fc 89       	ldd	r31, Y+20	; 0x14
    19b8:	aa 85       	ldd	r26, Y+10	; 0x0a
    19ba:	bb 85       	ldd	r27, Y+11	; 0x0b
    19bc:	b9 01       	movw	r22, r18
    19be:	4e 85       	ldd	r20, Y+14	; 0x0e
    19c0:	9f 01       	movw	r18, r30
    19c2:	8d 01       	movw	r16, r26
    19c4:	0e 94 06 12 	call	0x240c	; 0x240c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    19c8:	89 81       	ldd	r24, Y+1	; 0x01
    19ca:	9a 81       	ldd	r25, Y+2	; 0x02
    19cc:	2e 81       	ldd	r18, Y+6	; 0x06
    19ce:	3f 81       	ldd	r19, Y+7	; 0x07
    19d0:	4c 85       	ldd	r20, Y+12	; 0x0c
    19d2:	5d 85       	ldd	r21, Y+13	; 0x0d
    19d4:	b9 01       	movw	r22, r18
    19d6:	0e 94 49 05 	call	0xa92	; 0xa92 <pxPortInitialiseStack>
    19da:	eb 81       	ldd	r30, Y+3	; 0x03
    19dc:	fc 81       	ldd	r31, Y+4	; 0x04
    19de:	91 83       	std	Z+1, r25	; 0x01
    19e0:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    19e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    19e4:	98 89       	ldd	r25, Y+16	; 0x10
    19e6:	00 97       	sbiw	r24, 0x00	; 0
    19e8:	31 f0       	breq	.+12     	; 0x19f6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    19ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    19ec:	f8 89       	ldd	r31, Y+16	; 0x10
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	9c 81       	ldd	r25, Y+4	; 0x04
    19f2:	91 83       	std	Z+1, r25	; 0x01
    19f4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    19f6:	0f b6       	in	r0, 0x3f	; 63
    19f8:	f8 94       	cli
    19fa:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    19fc:	80 91 05 03 	lds	r24, 0x0305
    1a00:	8f 5f       	subi	r24, 0xFF	; 255
    1a02:	80 93 05 03 	sts	0x0305, r24
			if( pxCurrentTCB == NULL )
    1a06:	80 91 02 03 	lds	r24, 0x0302
    1a0a:	90 91 03 03 	lds	r25, 0x0303
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	69 f4       	brne	.+26     	; 0x1a2c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1a12:	8b 81       	ldd	r24, Y+3	; 0x03
    1a14:	9c 81       	ldd	r25, Y+4	; 0x04
    1a16:	90 93 03 03 	sts	0x0303, r25
    1a1a:	80 93 02 03 	sts	0x0302, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1a1e:	80 91 05 03 	lds	r24, 0x0305
    1a22:	81 30       	cpi	r24, 0x01	; 1
    1a24:	a9 f4       	brne	.+42     	; 0x1a50 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1a26:	0e 94 5d 12 	call	0x24ba	; 0x24ba <prvInitialiseTaskLists>
    1a2a:	12 c0       	rjmp	.+36     	; 0x1a50 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1a2c:	80 91 0a 03 	lds	r24, 0x030A
    1a30:	88 23       	and	r24, r24
    1a32:	71 f4       	brne	.+28     	; 0x1a50 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1a34:	e0 91 02 03 	lds	r30, 0x0302
    1a38:	f0 91 03 03 	lds	r31, 0x0303
    1a3c:	96 89       	ldd	r25, Z+22	; 0x16
    1a3e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a40:	89 17       	cp	r24, r25
    1a42:	30 f0       	brcs	.+12     	; 0x1a50 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1a44:	8b 81       	ldd	r24, Y+3	; 0x03
    1a46:	9c 81       	ldd	r25, Y+4	; 0x04
    1a48:	90 93 03 03 	sts	0x0303, r25
    1a4c:	80 93 02 03 	sts	0x0302, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1a50:	eb 81       	ldd	r30, Y+3	; 0x03
    1a52:	fc 81       	ldd	r31, Y+4	; 0x04
    1a54:	96 89       	ldd	r25, Z+22	; 0x16
    1a56:	80 91 08 03 	lds	r24, 0x0308
    1a5a:	89 17       	cp	r24, r25
    1a5c:	28 f4       	brcc	.+10     	; 0x1a68 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1a5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a60:	fc 81       	ldd	r31, Y+4	; 0x04
    1a62:	86 89       	ldd	r24, Z+22	; 0x16
    1a64:	80 93 08 03 	sts	0x0308, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a68:	80 91 0f 03 	lds	r24, 0x030F
    1a6c:	8f 5f       	subi	r24, 0xFF	; 255
    1a6e:	80 93 0f 03 	sts	0x030F, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a72:	eb 81       	ldd	r30, Y+3	; 0x03
    1a74:	fc 81       	ldd	r31, Y+4	; 0x04
    1a76:	96 89       	ldd	r25, Z+22	; 0x16
    1a78:	80 91 09 03 	lds	r24, 0x0309
    1a7c:	89 17       	cp	r24, r25
    1a7e:	28 f4       	brcc	.+10     	; 0x1a8a <xTaskGenericCreate+0x152>
    1a80:	eb 81       	ldd	r30, Y+3	; 0x03
    1a82:	fc 81       	ldd	r31, Y+4	; 0x04
    1a84:	86 89       	ldd	r24, Z+22	; 0x16
    1a86:	80 93 09 03 	sts	0x0309, r24
    1a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a8e:	86 89       	ldd	r24, Z+22	; 0x16
    1a90:	28 2f       	mov	r18, r24
    1a92:	30 e0       	ldi	r19, 0x00	; 0
    1a94:	c9 01       	movw	r24, r18
    1a96:	88 0f       	add	r24, r24
    1a98:	99 1f       	adc	r25, r25
    1a9a:	88 0f       	add	r24, r24
    1a9c:	99 1f       	adc	r25, r25
    1a9e:	88 0f       	add	r24, r24
    1aa0:	99 1f       	adc	r25, r25
    1aa2:	82 0f       	add	r24, r18
    1aa4:	93 1f       	adc	r25, r19
    1aa6:	ac 01       	movw	r20, r24
    1aa8:	40 5f       	subi	r20, 0xF0	; 240
    1aaa:	5c 4f       	sbci	r21, 0xFC	; 252
    1aac:	8b 81       	ldd	r24, Y+3	; 0x03
    1aae:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab0:	9c 01       	movw	r18, r24
    1ab2:	2e 5f       	subi	r18, 0xFE	; 254
    1ab4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ab6:	ca 01       	movw	r24, r20
    1ab8:	b9 01       	movw	r22, r18
    1aba:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>

			xReturn = pdPASS;
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1ac2:	0f 90       	pop	r0
    1ac4:	0f be       	out	0x3f, r0	; 63
    1ac6:	02 c0       	rjmp	.+4      	; 0x1acc <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1ac8:	8f ef       	ldi	r24, 0xFF	; 255
    1aca:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1acc:	8d 81       	ldd	r24, Y+5	; 0x05
    1ace:	81 30       	cpi	r24, 0x01	; 1
    1ad0:	71 f4       	brne	.+28     	; 0x1aee <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1ad2:	80 91 0a 03 	lds	r24, 0x030A
    1ad6:	88 23       	and	r24, r24
    1ad8:	51 f0       	breq	.+20     	; 0x1aee <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1ada:	e0 91 02 03 	lds	r30, 0x0302
    1ade:	f0 91 03 03 	lds	r31, 0x0303
    1ae2:	96 89       	ldd	r25, Z+22	; 0x16
    1ae4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ae6:	98 17       	cp	r25, r24
    1ae8:	10 f4       	brcc	.+4      	; 0x1aee <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1aea:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
			}
		}
	}

	return xReturn;
    1aee:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1af0:	64 96       	adiw	r28, 0x14	; 20
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	de bf       	out	0x3e, r29	; 62
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	cd bf       	out	0x3d, r28	; 61
    1afc:	cf 91       	pop	r28
    1afe:	df 91       	pop	r29
    1b00:	1f 91       	pop	r17
    1b02:	0f 91       	pop	r16
    1b04:	ff 90       	pop	r15
    1b06:	ef 90       	pop	r14
    1b08:	df 90       	pop	r13
    1b0a:	cf 90       	pop	r12
    1b0c:	bf 90       	pop	r11
    1b0e:	af 90       	pop	r10
    1b10:	08 95       	ret

00001b12 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1b12:	df 93       	push	r29
    1b14:	cf 93       	push	r28
    1b16:	00 d0       	rcall	.+0      	; 0x1b18 <vTaskDelete+0x6>
    1b18:	00 d0       	rcall	.+0      	; 0x1b1a <vTaskDelete+0x8>
    1b1a:	00 d0       	rcall	.+0      	; 0x1b1c <vTaskDelete+0xa>
    1b1c:	cd b7       	in	r28, 0x3d	; 61
    1b1e:	de b7       	in	r29, 0x3e	; 62
    1b20:	9c 83       	std	Y+4, r25	; 0x04
    1b22:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1b24:	0f b6       	in	r0, 0x3f	; 63
    1b26:	f8 94       	cli
    1b28:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1b2a:	20 91 02 03 	lds	r18, 0x0302
    1b2e:	30 91 03 03 	lds	r19, 0x0303
    1b32:	8b 81       	ldd	r24, Y+3	; 0x03
    1b34:	9c 81       	ldd	r25, Y+4	; 0x04
    1b36:	82 17       	cp	r24, r18
    1b38:	93 07       	cpc	r25, r19
    1b3a:	11 f4       	brne	.+4      	; 0x1b40 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1b3c:	1c 82       	std	Y+4, r1	; 0x04
    1b3e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	9c 81       	ldd	r25, Y+4	; 0x04
    1b44:	00 97       	sbiw	r24, 0x00	; 0
    1b46:	39 f4       	brne	.+14     	; 0x1b56 <vTaskDelete+0x44>
    1b48:	80 91 02 03 	lds	r24, 0x0302
    1b4c:	90 91 03 03 	lds	r25, 0x0303
    1b50:	9e 83       	std	Y+6, r25	; 0x06
    1b52:	8d 83       	std	Y+5, r24	; 0x05
    1b54:	04 c0       	rjmp	.+8      	; 0x1b5e <vTaskDelete+0x4c>
    1b56:	8b 81       	ldd	r24, Y+3	; 0x03
    1b58:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5a:	9e 83       	std	Y+6, r25	; 0x06
    1b5c:	8d 83       	std	Y+5, r24	; 0x05
    1b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b60:	9e 81       	ldd	r25, Y+6	; 0x06
    1b62:	9a 83       	std	Y+2, r25	; 0x02
    1b64:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6a:	02 96       	adiw	r24, 0x02	; 2
    1b6c:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b70:	e9 81       	ldd	r30, Y+1	; 0x01
    1b72:	fa 81       	ldd	r31, Y+2	; 0x02
    1b74:	84 89       	ldd	r24, Z+20	; 0x14
    1b76:	95 89       	ldd	r25, Z+21	; 0x15
    1b78:	00 97       	sbiw	r24, 0x00	; 0
    1b7a:	29 f0       	breq	.+10     	; 0x1b86 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b80:	0c 96       	adiw	r24, 0x0c	; 12
    1b82:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1b86:	89 81       	ldd	r24, Y+1	; 0x01
    1b88:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8a:	9c 01       	movw	r18, r24
    1b8c:	2e 5f       	subi	r18, 0xFE	; 254
    1b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b90:	8c e5       	ldi	r24, 0x5C	; 92
    1b92:	93 e0       	ldi	r25, 0x03	; 3
    1b94:	b9 01       	movw	r22, r18
    1b96:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1b9a:	80 91 04 03 	lds	r24, 0x0304
    1b9e:	8f 5f       	subi	r24, 0xFF	; 255
    1ba0:	80 93 04 03 	sts	0x0304, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1ba4:	80 91 0f 03 	lds	r24, 0x030F
    1ba8:	8f 5f       	subi	r24, 0xFF	; 255
    1baa:	80 93 0f 03 	sts	0x030F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1bae:	0f 90       	pop	r0
    1bb0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1bb2:	80 91 0a 03 	lds	r24, 0x030A
    1bb6:	88 23       	and	r24, r24
    1bb8:	31 f0       	breq	.+12     	; 0x1bc6 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1bba:	8b 81       	ldd	r24, Y+3	; 0x03
    1bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1bbe:	00 97       	sbiw	r24, 0x00	; 0
    1bc0:	11 f4       	brne	.+4      	; 0x1bc6 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1bc2:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
			}
		}
	}
    1bc6:	26 96       	adiw	r28, 0x06	; 6
    1bc8:	0f b6       	in	r0, 0x3f	; 63
    1bca:	f8 94       	cli
    1bcc:	de bf       	out	0x3e, r29	; 62
    1bce:	0f be       	out	0x3f, r0	; 63
    1bd0:	cd bf       	out	0x3d, r28	; 61
    1bd2:	cf 91       	pop	r28
    1bd4:	df 91       	pop	r29
    1bd6:	08 95       	ret

00001bd8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1bd8:	df 93       	push	r29
    1bda:	cf 93       	push	r28
    1bdc:	cd b7       	in	r28, 0x3d	; 61
    1bde:	de b7       	in	r29, 0x3e	; 62
    1be0:	28 97       	sbiw	r28, 0x08	; 8
    1be2:	0f b6       	in	r0, 0x3f	; 63
    1be4:	f8 94       	cli
    1be6:	de bf       	out	0x3e, r29	; 62
    1be8:	0f be       	out	0x3f, r0	; 63
    1bea:	cd bf       	out	0x3d, r28	; 61
    1bec:	9e 83       	std	Y+6, r25	; 0x06
    1bee:	8d 83       	std	Y+5, r24	; 0x05
    1bf0:	78 87       	std	Y+8, r23	; 0x08
    1bf2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1bf4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1bf6:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1bfa:	ed 81       	ldd	r30, Y+5	; 0x05
    1bfc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bfe:	20 81       	ld	r18, Z
    1c00:	31 81       	ldd	r19, Z+1	; 0x01
    1c02:	8f 81       	ldd	r24, Y+7	; 0x07
    1c04:	98 85       	ldd	r25, Y+8	; 0x08
    1c06:	82 0f       	add	r24, r18
    1c08:	93 1f       	adc	r25, r19
    1c0a:	9c 83       	std	Y+4, r25	; 0x04
    1c0c:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1c0e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c10:	fe 81       	ldd	r31, Y+6	; 0x06
    1c12:	20 81       	ld	r18, Z
    1c14:	31 81       	ldd	r19, Z+1	; 0x01
    1c16:	80 91 06 03 	lds	r24, 0x0306
    1c1a:	90 91 07 03 	lds	r25, 0x0307
    1c1e:	82 17       	cp	r24, r18
    1c20:	93 07       	cpc	r25, r19
    1c22:	a8 f4       	brcc	.+42     	; 0x1c4e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1c24:	ed 81       	ldd	r30, Y+5	; 0x05
    1c26:	fe 81       	ldd	r31, Y+6	; 0x06
    1c28:	20 81       	ld	r18, Z
    1c2a:	31 81       	ldd	r19, Z+1	; 0x01
    1c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c30:	82 17       	cp	r24, r18
    1c32:	93 07       	cpc	r25, r19
    1c34:	00 f5       	brcc	.+64     	; 0x1c76 <vTaskDelayUntil+0x9e>
    1c36:	20 91 06 03 	lds	r18, 0x0306
    1c3a:	30 91 07 03 	lds	r19, 0x0307
    1c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c40:	9c 81       	ldd	r25, Y+4	; 0x04
    1c42:	28 17       	cp	r18, r24
    1c44:	39 07       	cpc	r19, r25
    1c46:	b8 f4       	brcc	.+46     	; 0x1c76 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c48:	81 e0       	ldi	r24, 0x01	; 1
    1c4a:	89 83       	std	Y+1, r24	; 0x01
    1c4c:	14 c0       	rjmp	.+40     	; 0x1c76 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1c4e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c50:	fe 81       	ldd	r31, Y+6	; 0x06
    1c52:	20 81       	ld	r18, Z
    1c54:	31 81       	ldd	r19, Z+1	; 0x01
    1c56:	8b 81       	ldd	r24, Y+3	; 0x03
    1c58:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5a:	82 17       	cp	r24, r18
    1c5c:	93 07       	cpc	r25, r19
    1c5e:	48 f0       	brcs	.+18     	; 0x1c72 <vTaskDelayUntil+0x9a>
    1c60:	20 91 06 03 	lds	r18, 0x0306
    1c64:	30 91 07 03 	lds	r19, 0x0307
    1c68:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6c:	28 17       	cp	r18, r24
    1c6e:	39 07       	cpc	r19, r25
    1c70:	10 f4       	brcc	.+4      	; 0x1c76 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c76:	ed 81       	ldd	r30, Y+5	; 0x05
    1c78:	fe 81       	ldd	r31, Y+6	; 0x06
    1c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c7e:	91 83       	std	Z+1, r25	; 0x01
    1c80:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	88 23       	and	r24, r24
    1c86:	59 f0       	breq	.+22     	; 0x1c9e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c88:	80 91 02 03 	lds	r24, 0x0302
    1c8c:	90 91 03 03 	lds	r25, 0x0303
    1c90:	02 96       	adiw	r24, 0x02	; 2
    1c92:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c96:	8b 81       	ldd	r24, Y+3	; 0x03
    1c98:	9c 81       	ldd	r25, Y+4	; 0x04
    1c9a:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c9e:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
    1ca2:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca6:	88 23       	and	r24, r24
    1ca8:	11 f4       	brne	.+4      	; 0x1cae <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1caa:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
		}
	}
    1cae:	28 96       	adiw	r28, 0x08	; 8
    1cb0:	0f b6       	in	r0, 0x3f	; 63
    1cb2:	f8 94       	cli
    1cb4:	de bf       	out	0x3e, r29	; 62
    1cb6:	0f be       	out	0x3f, r0	; 63
    1cb8:	cd bf       	out	0x3d, r28	; 61
    1cba:	cf 91       	pop	r28
    1cbc:	df 91       	pop	r29
    1cbe:	08 95       	ret

00001cc0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1cc0:	df 93       	push	r29
    1cc2:	cf 93       	push	r28
    1cc4:	00 d0       	rcall	.+0      	; 0x1cc6 <vTaskDelay+0x6>
    1cc6:	00 d0       	rcall	.+0      	; 0x1cc8 <vTaskDelay+0x8>
    1cc8:	0f 92       	push	r0
    1cca:	cd b7       	in	r28, 0x3d	; 61
    1ccc:	de b7       	in	r29, 0x3e	; 62
    1cce:	9d 83       	std	Y+5, r25	; 0x05
    1cd0:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1cd2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1cd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cd6:	9d 81       	ldd	r25, Y+5	; 0x05
    1cd8:	00 97       	sbiw	r24, 0x00	; 0
    1cda:	d1 f0       	breq	.+52     	; 0x1d10 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1cdc:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1ce0:	20 91 06 03 	lds	r18, 0x0306
    1ce4:	30 91 07 03 	lds	r19, 0x0307
    1ce8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cea:	9d 81       	ldd	r25, Y+5	; 0x05
    1cec:	82 0f       	add	r24, r18
    1cee:	93 1f       	adc	r25, r19
    1cf0:	9b 83       	std	Y+3, r25	; 0x03
    1cf2:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1cf4:	80 91 02 03 	lds	r24, 0x0302
    1cf8:	90 91 03 03 	lds	r25, 0x0303
    1cfc:	02 96       	adiw	r24, 0x02	; 2
    1cfe:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d02:	8a 81       	ldd	r24, Y+2	; 0x02
    1d04:	9b 81       	ldd	r25, Y+3	; 0x03
    1d06:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1d0a:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>
    1d0e:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d10:	89 81       	ldd	r24, Y+1	; 0x01
    1d12:	88 23       	and	r24, r24
    1d14:	11 f4       	brne	.+4      	; 0x1d1a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1d16:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
		}
	}
    1d1a:	0f 90       	pop	r0
    1d1c:	0f 90       	pop	r0
    1d1e:	0f 90       	pop	r0
    1d20:	0f 90       	pop	r0
    1d22:	0f 90       	pop	r0
    1d24:	cf 91       	pop	r28
    1d26:	df 91       	pop	r29
    1d28:	08 95       	ret

00001d2a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1d2a:	af 92       	push	r10
    1d2c:	bf 92       	push	r11
    1d2e:	cf 92       	push	r12
    1d30:	df 92       	push	r13
    1d32:	ef 92       	push	r14
    1d34:	ff 92       	push	r15
    1d36:	0f 93       	push	r16
    1d38:	df 93       	push	r29
    1d3a:	cf 93       	push	r28
    1d3c:	0f 92       	push	r0
    1d3e:	cd b7       	in	r28, 0x3d	; 61
    1d40:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1d42:	26 e6       	ldi	r18, 0x66	; 102
    1d44:	30 e0       	ldi	r19, 0x00	; 0
    1d46:	8c ef       	ldi	r24, 0xFC	; 252
    1d48:	91 e1       	ldi	r25, 0x11	; 17
    1d4a:	b9 01       	movw	r22, r18
    1d4c:	45 e5       	ldi	r20, 0x55	; 85
    1d4e:	50 e0       	ldi	r21, 0x00	; 0
    1d50:	20 e0       	ldi	r18, 0x00	; 0
    1d52:	30 e0       	ldi	r19, 0x00	; 0
    1d54:	00 e0       	ldi	r16, 0x00	; 0
    1d56:	ee 24       	eor	r14, r14
    1d58:	ff 24       	eor	r15, r15
    1d5a:	cc 24       	eor	r12, r12
    1d5c:	dd 24       	eor	r13, r13
    1d5e:	aa 24       	eor	r10, r10
    1d60:	bb 24       	eor	r11, r11
    1d62:	0e 94 9c 0c 	call	0x1938	; 0x1938 <xTaskGenericCreate>
    1d66:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1d68:	89 81       	ldd	r24, Y+1	; 0x01
    1d6a:	81 30       	cpi	r24, 0x01	; 1
    1d6c:	51 f4       	brne	.+20     	; 0x1d82 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1d6e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1d70:	81 e0       	ldi	r24, 0x01	; 1
    1d72:	80 93 0a 03 	sts	0x030A, r24
		xTickCount = ( portTickType ) 0U;
    1d76:	10 92 07 03 	sts	0x0307, r1
    1d7a:	10 92 06 03 	sts	0x0306, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d7e:	0e 94 cc 06 	call	0xd98	; 0xd98 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1d82:	0f 90       	pop	r0
    1d84:	cf 91       	pop	r28
    1d86:	df 91       	pop	r29
    1d88:	0f 91       	pop	r16
    1d8a:	ff 90       	pop	r15
    1d8c:	ef 90       	pop	r14
    1d8e:	df 90       	pop	r13
    1d90:	cf 90       	pop	r12
    1d92:	bf 90       	pop	r11
    1d94:	af 90       	pop	r10
    1d96:	08 95       	ret

00001d98 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1d98:	df 93       	push	r29
    1d9a:	cf 93       	push	r28
    1d9c:	cd b7       	in	r28, 0x3d	; 61
    1d9e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1da0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1da2:	10 92 0a 03 	sts	0x030A, r1
	vPortEndScheduler();
    1da6:	0e 94 01 07 	call	0xe02	; 0xe02 <vPortEndScheduler>
}
    1daa:	cf 91       	pop	r28
    1dac:	df 91       	pop	r29
    1dae:	08 95       	ret

00001db0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1db0:	df 93       	push	r29
    1db2:	cf 93       	push	r28
    1db4:	cd b7       	in	r28, 0x3d	; 61
    1db6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1db8:	80 91 0b 03 	lds	r24, 0x030B
    1dbc:	8f 5f       	subi	r24, 0xFF	; 255
    1dbe:	80 93 0b 03 	sts	0x030B, r24
}
    1dc2:	cf 91       	pop	r28
    1dc4:	df 91       	pop	r29
    1dc6:	08 95       	ret

00001dc8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1dc8:	df 93       	push	r29
    1dca:	cf 93       	push	r28
    1dcc:	00 d0       	rcall	.+0      	; 0x1dce <xTaskResumeAll+0x6>
    1dce:	00 d0       	rcall	.+0      	; 0x1dd0 <xTaskResumeAll+0x8>
    1dd0:	cd b7       	in	r28, 0x3d	; 61
    1dd2:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1dd4:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1dd6:	0f b6       	in	r0, 0x3f	; 63
    1dd8:	f8 94       	cli
    1dda:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1ddc:	80 91 0b 03 	lds	r24, 0x030B
    1de0:	81 50       	subi	r24, 0x01	; 1
    1de2:	80 93 0b 03 	sts	0x030B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1de6:	80 91 0b 03 	lds	r24, 0x030B
    1dea:	88 23       	and	r24, r24
    1dec:	09 f0       	breq	.+2      	; 0x1df0 <xTaskResumeAll+0x28>
    1dee:	6c c0       	rjmp	.+216    	; 0x1ec8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1df0:	80 91 05 03 	lds	r24, 0x0305
    1df4:	88 23       	and	r24, r24
    1df6:	09 f4       	brne	.+2      	; 0x1dfa <xTaskResumeAll+0x32>
    1df8:	67 c0       	rjmp	.+206    	; 0x1ec8 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1dfa:	19 82       	std	Y+1, r1	; 0x01
    1dfc:	41 c0       	rjmp	.+130    	; 0x1e80 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1dfe:	e0 91 58 03 	lds	r30, 0x0358
    1e02:	f0 91 59 03 	lds	r31, 0x0359
    1e06:	86 81       	ldd	r24, Z+6	; 0x06
    1e08:	97 81       	ldd	r25, Z+7	; 0x07
    1e0a:	9c 83       	std	Y+4, r25	; 0x04
    1e0c:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	9c 81       	ldd	r25, Y+4	; 0x04
    1e12:	0c 96       	adiw	r24, 0x0c	; 12
    1e14:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e18:	8b 81       	ldd	r24, Y+3	; 0x03
    1e1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e1c:	02 96       	adiw	r24, 0x02	; 2
    1e1e:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e22:	eb 81       	ldd	r30, Y+3	; 0x03
    1e24:	fc 81       	ldd	r31, Y+4	; 0x04
    1e26:	96 89       	ldd	r25, Z+22	; 0x16
    1e28:	80 91 09 03 	lds	r24, 0x0309
    1e2c:	89 17       	cp	r24, r25
    1e2e:	28 f4       	brcc	.+10     	; 0x1e3a <xTaskResumeAll+0x72>
    1e30:	eb 81       	ldd	r30, Y+3	; 0x03
    1e32:	fc 81       	ldd	r31, Y+4	; 0x04
    1e34:	86 89       	ldd	r24, Z+22	; 0x16
    1e36:	80 93 09 03 	sts	0x0309, r24
    1e3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e3e:	86 89       	ldd	r24, Z+22	; 0x16
    1e40:	28 2f       	mov	r18, r24
    1e42:	30 e0       	ldi	r19, 0x00	; 0
    1e44:	c9 01       	movw	r24, r18
    1e46:	88 0f       	add	r24, r24
    1e48:	99 1f       	adc	r25, r25
    1e4a:	88 0f       	add	r24, r24
    1e4c:	99 1f       	adc	r25, r25
    1e4e:	88 0f       	add	r24, r24
    1e50:	99 1f       	adc	r25, r25
    1e52:	82 0f       	add	r24, r18
    1e54:	93 1f       	adc	r25, r19
    1e56:	80 5f       	subi	r24, 0xF0	; 240
    1e58:	9c 4f       	sbci	r25, 0xFC	; 252
    1e5a:	2b 81       	ldd	r18, Y+3	; 0x03
    1e5c:	3c 81       	ldd	r19, Y+4	; 0x04
    1e5e:	2e 5f       	subi	r18, 0xFE	; 254
    1e60:	3f 4f       	sbci	r19, 0xFF	; 255
    1e62:	b9 01       	movw	r22, r18
    1e64:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e68:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e6c:	96 89       	ldd	r25, Z+22	; 0x16
    1e6e:	e0 91 02 03 	lds	r30, 0x0302
    1e72:	f0 91 03 03 	lds	r31, 0x0303
    1e76:	86 89       	ldd	r24, Z+22	; 0x16
    1e78:	98 17       	cp	r25, r24
    1e7a:	10 f0       	brcs	.+4      	; 0x1e80 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1e80:	80 91 53 03 	lds	r24, 0x0353
    1e84:	88 23       	and	r24, r24
    1e86:	09 f0       	breq	.+2      	; 0x1e8a <xTaskResumeAll+0xc2>
    1e88:	ba cf       	rjmp	.-140    	; 0x1dfe <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e8a:	80 91 0c 03 	lds	r24, 0x030C
    1e8e:	88 23       	and	r24, r24
    1e90:	71 f0       	breq	.+28     	; 0x1eae <xTaskResumeAll+0xe6>
    1e92:	07 c0       	rjmp	.+14     	; 0x1ea2 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1e94:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskIncrementTick>
						--uxMissedTicks;
    1e98:	80 91 0c 03 	lds	r24, 0x030C
    1e9c:	81 50       	subi	r24, 0x01	; 1
    1e9e:	80 93 0c 03 	sts	0x030C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ea2:	80 91 0c 03 	lds	r24, 0x030C
    1ea6:	88 23       	and	r24, r24
    1ea8:	a9 f7       	brne	.-22     	; 0x1e94 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1eaa:	81 e0       	ldi	r24, 0x01	; 1
    1eac:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1eae:	89 81       	ldd	r24, Y+1	; 0x01
    1eb0:	81 30       	cpi	r24, 0x01	; 1
    1eb2:	21 f0       	breq	.+8      	; 0x1ebc <xTaskResumeAll+0xf4>
    1eb4:	80 91 0d 03 	lds	r24, 0x030D
    1eb8:	81 30       	cpi	r24, 0x01	; 1
    1eba:	31 f4       	brne	.+12     	; 0x1ec8 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1ec0:	10 92 0d 03 	sts	0x030D, r1
					portYIELD_WITHIN_API();
    1ec4:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1ecc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ece:	0f 90       	pop	r0
    1ed0:	0f 90       	pop	r0
    1ed2:	0f 90       	pop	r0
    1ed4:	0f 90       	pop	r0
    1ed6:	cf 91       	pop	r28
    1ed8:	df 91       	pop	r29
    1eda:	08 95       	ret

00001edc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1edc:	df 93       	push	r29
    1ede:	cf 93       	push	r28
    1ee0:	00 d0       	rcall	.+0      	; 0x1ee2 <xTaskGetTickCount+0x6>
    1ee2:	cd b7       	in	r28, 0x3d	; 61
    1ee4:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1ee6:	0f b6       	in	r0, 0x3f	; 63
    1ee8:	f8 94       	cli
    1eea:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1eec:	80 91 06 03 	lds	r24, 0x0306
    1ef0:	90 91 07 03 	lds	r25, 0x0307
    1ef4:	9a 83       	std	Y+2, r25	; 0x02
    1ef6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1ef8:	0f 90       	pop	r0
    1efa:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1efc:	89 81       	ldd	r24, Y+1	; 0x01
    1efe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1f00:	0f 90       	pop	r0
    1f02:	0f 90       	pop	r0
    1f04:	cf 91       	pop	r28
    1f06:	df 91       	pop	r29
    1f08:	08 95       	ret

00001f0a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1f0a:	df 93       	push	r29
    1f0c:	cf 93       	push	r28
    1f0e:	00 d0       	rcall	.+0      	; 0x1f10 <xTaskGetTickCountFromISR+0x6>
    1f10:	0f 92       	push	r0
    1f12:	cd b7       	in	r28, 0x3d	; 61
    1f14:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f16:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1f18:	80 91 06 03 	lds	r24, 0x0306
    1f1c:	90 91 07 03 	lds	r25, 0x0307
    1f20:	9b 83       	std	Y+3, r25	; 0x03
    1f22:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f24:	8a 81       	ldd	r24, Y+2	; 0x02
    1f26:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1f28:	0f 90       	pop	r0
    1f2a:	0f 90       	pop	r0
    1f2c:	0f 90       	pop	r0
    1f2e:	cf 91       	pop	r28
    1f30:	df 91       	pop	r29
    1f32:	08 95       	ret

00001f34 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1f34:	df 93       	push	r29
    1f36:	cf 93       	push	r28
    1f38:	cd b7       	in	r28, 0x3d	; 61
    1f3a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1f3c:	80 91 05 03 	lds	r24, 0x0305
}
    1f40:	cf 91       	pop	r28
    1f42:	df 91       	pop	r29
    1f44:	08 95       	ret

00001f46 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1f46:	df 93       	push	r29
    1f48:	cf 93       	push	r28
    1f4a:	00 d0       	rcall	.+0      	; 0x1f4c <vTaskIncrementTick+0x6>
    1f4c:	00 d0       	rcall	.+0      	; 0x1f4e <vTaskIncrementTick+0x8>
    1f4e:	00 d0       	rcall	.+0      	; 0x1f50 <vTaskIncrementTick+0xa>
    1f50:	cd b7       	in	r28, 0x3d	; 61
    1f52:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f54:	80 91 0b 03 	lds	r24, 0x030B
    1f58:	88 23       	and	r24, r24
    1f5a:	09 f0       	breq	.+2      	; 0x1f5e <vTaskIncrementTick+0x18>
    1f5c:	bb c0       	rjmp	.+374    	; 0x20d4 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1f5e:	80 91 06 03 	lds	r24, 0x0306
    1f62:	90 91 07 03 	lds	r25, 0x0307
    1f66:	01 96       	adiw	r24, 0x01	; 1
    1f68:	90 93 07 03 	sts	0x0307, r25
    1f6c:	80 93 06 03 	sts	0x0306, r24
		if( xTickCount == ( portTickType ) 0U )
    1f70:	80 91 06 03 	lds	r24, 0x0306
    1f74:	90 91 07 03 	lds	r25, 0x0307
    1f78:	00 97       	sbiw	r24, 0x00	; 0
    1f7a:	d1 f5       	brne	.+116    	; 0x1ff0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1f7c:	80 91 4f 03 	lds	r24, 0x034F
    1f80:	90 91 50 03 	lds	r25, 0x0350
    1f84:	9c 83       	std	Y+4, r25	; 0x04
    1f86:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1f88:	80 91 51 03 	lds	r24, 0x0351
    1f8c:	90 91 52 03 	lds	r25, 0x0352
    1f90:	90 93 50 03 	sts	0x0350, r25
    1f94:	80 93 4f 03 	sts	0x034F, r24
			pxOverflowDelayedTaskList = pxTemp;
    1f98:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9c:	90 93 52 03 	sts	0x0352, r25
    1fa0:	80 93 51 03 	sts	0x0351, r24
			xNumOfOverflows++;
    1fa4:	80 91 0e 03 	lds	r24, 0x030E
    1fa8:	8f 5f       	subi	r24, 0xFF	; 255
    1faa:	80 93 0e 03 	sts	0x030E, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1fae:	e0 91 4f 03 	lds	r30, 0x034F
    1fb2:	f0 91 50 03 	lds	r31, 0x0350
    1fb6:	80 81       	ld	r24, Z
    1fb8:	88 23       	and	r24, r24
    1fba:	39 f4       	brne	.+14     	; 0x1fca <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1fbc:	8f ef       	ldi	r24, 0xFF	; 255
    1fbe:	9f ef       	ldi	r25, 0xFF	; 255
    1fc0:	90 93 6c 00 	sts	0x006C, r25
    1fc4:	80 93 6b 00 	sts	0x006B, r24
    1fc8:	13 c0       	rjmp	.+38     	; 0x1ff0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1fca:	e0 91 4f 03 	lds	r30, 0x034F
    1fce:	f0 91 50 03 	lds	r31, 0x0350
    1fd2:	05 80       	ldd	r0, Z+5	; 0x05
    1fd4:	f6 81       	ldd	r31, Z+6	; 0x06
    1fd6:	e0 2d       	mov	r30, r0
    1fd8:	86 81       	ldd	r24, Z+6	; 0x06
    1fda:	97 81       	ldd	r25, Z+7	; 0x07
    1fdc:	9e 83       	std	Y+6, r25	; 0x06
    1fde:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1fe0:	ed 81       	ldd	r30, Y+5	; 0x05
    1fe2:	fe 81       	ldd	r31, Y+6	; 0x06
    1fe4:	82 81       	ldd	r24, Z+2	; 0x02
    1fe6:	93 81       	ldd	r25, Z+3	; 0x03
    1fe8:	90 93 6c 00 	sts	0x006C, r25
    1fec:	80 93 6b 00 	sts	0x006B, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1ff0:	20 91 06 03 	lds	r18, 0x0306
    1ff4:	30 91 07 03 	lds	r19, 0x0307
    1ff8:	80 91 6b 00 	lds	r24, 0x006B
    1ffc:	90 91 6c 00 	lds	r25, 0x006C
    2000:	28 17       	cp	r18, r24
    2002:	39 07       	cpc	r19, r25
    2004:	08 f4       	brcc	.+2      	; 0x2008 <vTaskIncrementTick+0xc2>
    2006:	6b c0       	rjmp	.+214    	; 0x20de <vTaskIncrementTick+0x198>
    2008:	e0 91 4f 03 	lds	r30, 0x034F
    200c:	f0 91 50 03 	lds	r31, 0x0350
    2010:	80 81       	ld	r24, Z
    2012:	88 23       	and	r24, r24
    2014:	39 f4       	brne	.+14     	; 0x2024 <vTaskIncrementTick+0xde>
    2016:	8f ef       	ldi	r24, 0xFF	; 255
    2018:	9f ef       	ldi	r25, 0xFF	; 255
    201a:	90 93 6c 00 	sts	0x006C, r25
    201e:	80 93 6b 00 	sts	0x006B, r24
    2022:	5d c0       	rjmp	.+186    	; 0x20de <vTaskIncrementTick+0x198>
    2024:	e0 91 4f 03 	lds	r30, 0x034F
    2028:	f0 91 50 03 	lds	r31, 0x0350
    202c:	05 80       	ldd	r0, Z+5	; 0x05
    202e:	f6 81       	ldd	r31, Z+6	; 0x06
    2030:	e0 2d       	mov	r30, r0
    2032:	86 81       	ldd	r24, Z+6	; 0x06
    2034:	97 81       	ldd	r25, Z+7	; 0x07
    2036:	9e 83       	std	Y+6, r25	; 0x06
    2038:	8d 83       	std	Y+5, r24	; 0x05
    203a:	ed 81       	ldd	r30, Y+5	; 0x05
    203c:	fe 81       	ldd	r31, Y+6	; 0x06
    203e:	82 81       	ldd	r24, Z+2	; 0x02
    2040:	93 81       	ldd	r25, Z+3	; 0x03
    2042:	9a 83       	std	Y+2, r25	; 0x02
    2044:	89 83       	std	Y+1, r24	; 0x01
    2046:	20 91 06 03 	lds	r18, 0x0306
    204a:	30 91 07 03 	lds	r19, 0x0307
    204e:	89 81       	ldd	r24, Y+1	; 0x01
    2050:	9a 81       	ldd	r25, Y+2	; 0x02
    2052:	28 17       	cp	r18, r24
    2054:	39 07       	cpc	r19, r25
    2056:	38 f4       	brcc	.+14     	; 0x2066 <vTaskIncrementTick+0x120>
    2058:	89 81       	ldd	r24, Y+1	; 0x01
    205a:	9a 81       	ldd	r25, Y+2	; 0x02
    205c:	90 93 6c 00 	sts	0x006C, r25
    2060:	80 93 6b 00 	sts	0x006B, r24
    2064:	3c c0       	rjmp	.+120    	; 0x20de <vTaskIncrementTick+0x198>
    2066:	8d 81       	ldd	r24, Y+5	; 0x05
    2068:	9e 81       	ldd	r25, Y+6	; 0x06
    206a:	02 96       	adiw	r24, 0x02	; 2
    206c:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
    2070:	ed 81       	ldd	r30, Y+5	; 0x05
    2072:	fe 81       	ldd	r31, Y+6	; 0x06
    2074:	84 89       	ldd	r24, Z+20	; 0x14
    2076:	95 89       	ldd	r25, Z+21	; 0x15
    2078:	00 97       	sbiw	r24, 0x00	; 0
    207a:	29 f0       	breq	.+10     	; 0x2086 <vTaskIncrementTick+0x140>
    207c:	8d 81       	ldd	r24, Y+5	; 0x05
    207e:	9e 81       	ldd	r25, Y+6	; 0x06
    2080:	0c 96       	adiw	r24, 0x0c	; 12
    2082:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
    2086:	ed 81       	ldd	r30, Y+5	; 0x05
    2088:	fe 81       	ldd	r31, Y+6	; 0x06
    208a:	96 89       	ldd	r25, Z+22	; 0x16
    208c:	80 91 09 03 	lds	r24, 0x0309
    2090:	89 17       	cp	r24, r25
    2092:	28 f4       	brcc	.+10     	; 0x209e <vTaskIncrementTick+0x158>
    2094:	ed 81       	ldd	r30, Y+5	; 0x05
    2096:	fe 81       	ldd	r31, Y+6	; 0x06
    2098:	86 89       	ldd	r24, Z+22	; 0x16
    209a:	80 93 09 03 	sts	0x0309, r24
    209e:	ed 81       	ldd	r30, Y+5	; 0x05
    20a0:	fe 81       	ldd	r31, Y+6	; 0x06
    20a2:	86 89       	ldd	r24, Z+22	; 0x16
    20a4:	28 2f       	mov	r18, r24
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	c9 01       	movw	r24, r18
    20aa:	88 0f       	add	r24, r24
    20ac:	99 1f       	adc	r25, r25
    20ae:	88 0f       	add	r24, r24
    20b0:	99 1f       	adc	r25, r25
    20b2:	88 0f       	add	r24, r24
    20b4:	99 1f       	adc	r25, r25
    20b6:	82 0f       	add	r24, r18
    20b8:	93 1f       	adc	r25, r19
    20ba:	ac 01       	movw	r20, r24
    20bc:	40 5f       	subi	r20, 0xF0	; 240
    20be:	5c 4f       	sbci	r21, 0xFC	; 252
    20c0:	8d 81       	ldd	r24, Y+5	; 0x05
    20c2:	9e 81       	ldd	r25, Y+6	; 0x06
    20c4:	9c 01       	movw	r18, r24
    20c6:	2e 5f       	subi	r18, 0xFE	; 254
    20c8:	3f 4f       	sbci	r19, 0xFF	; 255
    20ca:	ca 01       	movw	r24, r20
    20cc:	b9 01       	movw	r22, r18
    20ce:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>
    20d2:	9a cf       	rjmp	.-204    	; 0x2008 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    20d4:	80 91 0c 03 	lds	r24, 0x030C
    20d8:	8f 5f       	subi	r24, 0xFF	; 255
    20da:	80 93 0c 03 	sts	0x030C, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    20de:	26 96       	adiw	r28, 0x06	; 6
    20e0:	0f b6       	in	r0, 0x3f	; 63
    20e2:	f8 94       	cli
    20e4:	de bf       	out	0x3e, r29	; 62
    20e6:	0f be       	out	0x3f, r0	; 63
    20e8:	cd bf       	out	0x3d, r28	; 61
    20ea:	cf 91       	pop	r28
    20ec:	df 91       	pop	r29
    20ee:	08 95       	ret

000020f0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    20f0:	df 93       	push	r29
    20f2:	cf 93       	push	r28
    20f4:	00 d0       	rcall	.+0      	; 0x20f6 <vTaskSwitchContext+0x6>
    20f6:	cd b7       	in	r28, 0x3d	; 61
    20f8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20fa:	80 91 0b 03 	lds	r24, 0x030B
    20fe:	88 23       	and	r24, r24
    2100:	49 f0       	breq	.+18     	; 0x2114 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2102:	81 e0       	ldi	r24, 0x01	; 1
    2104:	80 93 0d 03 	sts	0x030D, r24
    2108:	54 c0       	rjmp	.+168    	; 0x21b2 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    210a:	80 91 09 03 	lds	r24, 0x0309
    210e:	81 50       	subi	r24, 0x01	; 1
    2110:	80 93 09 03 	sts	0x0309, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2114:	80 91 09 03 	lds	r24, 0x0309
    2118:	28 2f       	mov	r18, r24
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	c9 01       	movw	r24, r18
    211e:	88 0f       	add	r24, r24
    2120:	99 1f       	adc	r25, r25
    2122:	88 0f       	add	r24, r24
    2124:	99 1f       	adc	r25, r25
    2126:	88 0f       	add	r24, r24
    2128:	99 1f       	adc	r25, r25
    212a:	82 0f       	add	r24, r18
    212c:	93 1f       	adc	r25, r19
    212e:	fc 01       	movw	r30, r24
    2130:	e0 5f       	subi	r30, 0xF0	; 240
    2132:	fc 4f       	sbci	r31, 0xFC	; 252
    2134:	80 81       	ld	r24, Z
    2136:	88 23       	and	r24, r24
    2138:	41 f3       	breq	.-48     	; 0x210a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    213a:	80 91 09 03 	lds	r24, 0x0309
    213e:	28 2f       	mov	r18, r24
    2140:	30 e0       	ldi	r19, 0x00	; 0
    2142:	c9 01       	movw	r24, r18
    2144:	88 0f       	add	r24, r24
    2146:	99 1f       	adc	r25, r25
    2148:	88 0f       	add	r24, r24
    214a:	99 1f       	adc	r25, r25
    214c:	88 0f       	add	r24, r24
    214e:	99 1f       	adc	r25, r25
    2150:	82 0f       	add	r24, r18
    2152:	93 1f       	adc	r25, r19
    2154:	80 5f       	subi	r24, 0xF0	; 240
    2156:	9c 4f       	sbci	r25, 0xFC	; 252
    2158:	9a 83       	std	Y+2, r25	; 0x02
    215a:	89 83       	std	Y+1, r24	; 0x01
    215c:	e9 81       	ldd	r30, Y+1	; 0x01
    215e:	fa 81       	ldd	r31, Y+2	; 0x02
    2160:	01 80       	ldd	r0, Z+1	; 0x01
    2162:	f2 81       	ldd	r31, Z+2	; 0x02
    2164:	e0 2d       	mov	r30, r0
    2166:	82 81       	ldd	r24, Z+2	; 0x02
    2168:	93 81       	ldd	r25, Z+3	; 0x03
    216a:	e9 81       	ldd	r30, Y+1	; 0x01
    216c:	fa 81       	ldd	r31, Y+2	; 0x02
    216e:	92 83       	std	Z+2, r25	; 0x02
    2170:	81 83       	std	Z+1, r24	; 0x01
    2172:	e9 81       	ldd	r30, Y+1	; 0x01
    2174:	fa 81       	ldd	r31, Y+2	; 0x02
    2176:	21 81       	ldd	r18, Z+1	; 0x01
    2178:	32 81       	ldd	r19, Z+2	; 0x02
    217a:	89 81       	ldd	r24, Y+1	; 0x01
    217c:	9a 81       	ldd	r25, Y+2	; 0x02
    217e:	03 96       	adiw	r24, 0x03	; 3
    2180:	28 17       	cp	r18, r24
    2182:	39 07       	cpc	r19, r25
    2184:	59 f4       	brne	.+22     	; 0x219c <vTaskSwitchContext+0xac>
    2186:	e9 81       	ldd	r30, Y+1	; 0x01
    2188:	fa 81       	ldd	r31, Y+2	; 0x02
    218a:	01 80       	ldd	r0, Z+1	; 0x01
    218c:	f2 81       	ldd	r31, Z+2	; 0x02
    218e:	e0 2d       	mov	r30, r0
    2190:	82 81       	ldd	r24, Z+2	; 0x02
    2192:	93 81       	ldd	r25, Z+3	; 0x03
    2194:	e9 81       	ldd	r30, Y+1	; 0x01
    2196:	fa 81       	ldd	r31, Y+2	; 0x02
    2198:	92 83       	std	Z+2, r25	; 0x02
    219a:	81 83       	std	Z+1, r24	; 0x01
    219c:	e9 81       	ldd	r30, Y+1	; 0x01
    219e:	fa 81       	ldd	r31, Y+2	; 0x02
    21a0:	01 80       	ldd	r0, Z+1	; 0x01
    21a2:	f2 81       	ldd	r31, Z+2	; 0x02
    21a4:	e0 2d       	mov	r30, r0
    21a6:	86 81       	ldd	r24, Z+6	; 0x06
    21a8:	97 81       	ldd	r25, Z+7	; 0x07
    21aa:	90 93 03 03 	sts	0x0303, r25
    21ae:	80 93 02 03 	sts	0x0302, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    21b2:	0f 90       	pop	r0
    21b4:	0f 90       	pop	r0
    21b6:	cf 91       	pop	r28
    21b8:	df 91       	pop	r29
    21ba:	08 95       	ret

000021bc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    21bc:	df 93       	push	r29
    21be:	cf 93       	push	r28
    21c0:	00 d0       	rcall	.+0      	; 0x21c2 <vTaskPlaceOnEventList+0x6>
    21c2:	00 d0       	rcall	.+0      	; 0x21c4 <vTaskPlaceOnEventList+0x8>
    21c4:	00 d0       	rcall	.+0      	; 0x21c6 <vTaskPlaceOnEventList+0xa>
    21c6:	cd b7       	in	r28, 0x3d	; 61
    21c8:	de b7       	in	r29, 0x3e	; 62
    21ca:	9c 83       	std	Y+4, r25	; 0x04
    21cc:	8b 83       	std	Y+3, r24	; 0x03
    21ce:	7e 83       	std	Y+6, r23	; 0x06
    21d0:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    21d2:	4b 81       	ldd	r20, Y+3	; 0x03
    21d4:	5c 81       	ldd	r21, Y+4	; 0x04
    21d6:	80 91 02 03 	lds	r24, 0x0302
    21da:	90 91 03 03 	lds	r25, 0x0303
    21de:	9c 01       	movw	r18, r24
    21e0:	24 5f       	subi	r18, 0xF4	; 244
    21e2:	3f 4f       	sbci	r19, 0xFF	; 255
    21e4:	ca 01       	movw	r24, r20
    21e6:	b9 01       	movw	r22, r18
    21e8:	0e 94 94 04 	call	0x928	; 0x928 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    21ec:	80 91 02 03 	lds	r24, 0x0302
    21f0:	90 91 03 03 	lds	r25, 0x0303
    21f4:	02 96       	adiw	r24, 0x02	; 2
    21f6:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21fa:	20 91 06 03 	lds	r18, 0x0306
    21fe:	30 91 07 03 	lds	r19, 0x0307
    2202:	8d 81       	ldd	r24, Y+5	; 0x05
    2204:	9e 81       	ldd	r25, Y+6	; 0x06
    2206:	82 0f       	add	r24, r18
    2208:	93 1f       	adc	r25, r19
    220a:	9a 83       	std	Y+2, r25	; 0x02
    220c:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    220e:	89 81       	ldd	r24, Y+1	; 0x01
    2210:	9a 81       	ldd	r25, Y+2	; 0x02
    2212:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2216:	26 96       	adiw	r28, 0x06	; 6
    2218:	0f b6       	in	r0, 0x3f	; 63
    221a:	f8 94       	cli
    221c:	de bf       	out	0x3e, r29	; 62
    221e:	0f be       	out	0x3f, r0	; 63
    2220:	cd bf       	out	0x3d, r28	; 61
    2222:	cf 91       	pop	r28
    2224:	df 91       	pop	r29
    2226:	08 95       	ret

00002228 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2228:	df 93       	push	r29
    222a:	cf 93       	push	r28
    222c:	00 d0       	rcall	.+0      	; 0x222e <xTaskRemoveFromEventList+0x6>
    222e:	00 d0       	rcall	.+0      	; 0x2230 <xTaskRemoveFromEventList+0x8>
    2230:	0f 92       	push	r0
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
    2236:	9d 83       	std	Y+5, r25	; 0x05
    2238:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    223a:	ec 81       	ldd	r30, Y+4	; 0x04
    223c:	fd 81       	ldd	r31, Y+5	; 0x05
    223e:	05 80       	ldd	r0, Z+5	; 0x05
    2240:	f6 81       	ldd	r31, Z+6	; 0x06
    2242:	e0 2d       	mov	r30, r0
    2244:	86 81       	ldd	r24, Z+6	; 0x06
    2246:	97 81       	ldd	r25, Z+7	; 0x07
    2248:	9b 83       	std	Y+3, r25	; 0x03
    224a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    224c:	8a 81       	ldd	r24, Y+2	; 0x02
    224e:	9b 81       	ldd	r25, Y+3	; 0x03
    2250:	0c 96       	adiw	r24, 0x0c	; 12
    2252:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2256:	80 91 0b 03 	lds	r24, 0x030B
    225a:	88 23       	and	r24, r24
    225c:	61 f5       	brne	.+88     	; 0x22b6 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    225e:	8a 81       	ldd	r24, Y+2	; 0x02
    2260:	9b 81       	ldd	r25, Y+3	; 0x03
    2262:	02 96       	adiw	r24, 0x02	; 2
    2264:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2268:	ea 81       	ldd	r30, Y+2	; 0x02
    226a:	fb 81       	ldd	r31, Y+3	; 0x03
    226c:	96 89       	ldd	r25, Z+22	; 0x16
    226e:	80 91 09 03 	lds	r24, 0x0309
    2272:	89 17       	cp	r24, r25
    2274:	28 f4       	brcc	.+10     	; 0x2280 <xTaskRemoveFromEventList+0x58>
    2276:	ea 81       	ldd	r30, Y+2	; 0x02
    2278:	fb 81       	ldd	r31, Y+3	; 0x03
    227a:	86 89       	ldd	r24, Z+22	; 0x16
    227c:	80 93 09 03 	sts	0x0309, r24
    2280:	ea 81       	ldd	r30, Y+2	; 0x02
    2282:	fb 81       	ldd	r31, Y+3	; 0x03
    2284:	86 89       	ldd	r24, Z+22	; 0x16
    2286:	28 2f       	mov	r18, r24
    2288:	30 e0       	ldi	r19, 0x00	; 0
    228a:	c9 01       	movw	r24, r18
    228c:	88 0f       	add	r24, r24
    228e:	99 1f       	adc	r25, r25
    2290:	88 0f       	add	r24, r24
    2292:	99 1f       	adc	r25, r25
    2294:	88 0f       	add	r24, r24
    2296:	99 1f       	adc	r25, r25
    2298:	82 0f       	add	r24, r18
    229a:	93 1f       	adc	r25, r19
    229c:	ac 01       	movw	r20, r24
    229e:	40 5f       	subi	r20, 0xF0	; 240
    22a0:	5c 4f       	sbci	r21, 0xFC	; 252
    22a2:	8a 81       	ldd	r24, Y+2	; 0x02
    22a4:	9b 81       	ldd	r25, Y+3	; 0x03
    22a6:	9c 01       	movw	r18, r24
    22a8:	2e 5f       	subi	r18, 0xFE	; 254
    22aa:	3f 4f       	sbci	r19, 0xFF	; 255
    22ac:	ca 01       	movw	r24, r20
    22ae:	b9 01       	movw	r22, r18
    22b0:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>
    22b4:	0a c0       	rjmp	.+20     	; 0x22ca <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    22b6:	8a 81       	ldd	r24, Y+2	; 0x02
    22b8:	9b 81       	ldd	r25, Y+3	; 0x03
    22ba:	9c 01       	movw	r18, r24
    22bc:	24 5f       	subi	r18, 0xF4	; 244
    22be:	3f 4f       	sbci	r19, 0xFF	; 255
    22c0:	83 e5       	ldi	r24, 0x53	; 83
    22c2:	93 e0       	ldi	r25, 0x03	; 3
    22c4:	b9 01       	movw	r22, r18
    22c6:	0e 94 48 04 	call	0x890	; 0x890 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22ca:	ea 81       	ldd	r30, Y+2	; 0x02
    22cc:	fb 81       	ldd	r31, Y+3	; 0x03
    22ce:	96 89       	ldd	r25, Z+22	; 0x16
    22d0:	e0 91 02 03 	lds	r30, 0x0302
    22d4:	f0 91 03 03 	lds	r31, 0x0303
    22d8:	86 89       	ldd	r24, Z+22	; 0x16
    22da:	98 17       	cp	r25, r24
    22dc:	18 f0       	brcs	.+6      	; 0x22e4 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    22de:	81 e0       	ldi	r24, 0x01	; 1
    22e0:	89 83       	std	Y+1, r24	; 0x01
    22e2:	01 c0       	rjmp	.+2      	; 0x22e6 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    22e4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    22e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    22e8:	0f 90       	pop	r0
    22ea:	0f 90       	pop	r0
    22ec:	0f 90       	pop	r0
    22ee:	0f 90       	pop	r0
    22f0:	0f 90       	pop	r0
    22f2:	cf 91       	pop	r28
    22f4:	df 91       	pop	r29
    22f6:	08 95       	ret

000022f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    22f8:	df 93       	push	r29
    22fa:	cf 93       	push	r28
    22fc:	00 d0       	rcall	.+0      	; 0x22fe <vTaskSetTimeOutState+0x6>
    22fe:	cd b7       	in	r28, 0x3d	; 61
    2300:	de b7       	in	r29, 0x3e	; 62
    2302:	9a 83       	std	Y+2, r25	; 0x02
    2304:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2306:	80 91 0e 03 	lds	r24, 0x030E
    230a:	e9 81       	ldd	r30, Y+1	; 0x01
    230c:	fa 81       	ldd	r31, Y+2	; 0x02
    230e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2310:	80 91 06 03 	lds	r24, 0x0306
    2314:	90 91 07 03 	lds	r25, 0x0307
    2318:	e9 81       	ldd	r30, Y+1	; 0x01
    231a:	fa 81       	ldd	r31, Y+2	; 0x02
    231c:	92 83       	std	Z+2, r25	; 0x02
    231e:	81 83       	std	Z+1, r24	; 0x01
}
    2320:	0f 90       	pop	r0
    2322:	0f 90       	pop	r0
    2324:	cf 91       	pop	r28
    2326:	df 91       	pop	r29
    2328:	08 95       	ret

0000232a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    232a:	df 93       	push	r29
    232c:	cf 93       	push	r28
    232e:	00 d0       	rcall	.+0      	; 0x2330 <xTaskCheckForTimeOut+0x6>
    2330:	00 d0       	rcall	.+0      	; 0x2332 <xTaskCheckForTimeOut+0x8>
    2332:	0f 92       	push	r0
    2334:	cd b7       	in	r28, 0x3d	; 61
    2336:	de b7       	in	r29, 0x3e	; 62
    2338:	9b 83       	std	Y+3, r25	; 0x03
    233a:	8a 83       	std	Y+2, r24	; 0x02
    233c:	7d 83       	std	Y+5, r23	; 0x05
    233e:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2346:	ea 81       	ldd	r30, Y+2	; 0x02
    2348:	fb 81       	ldd	r31, Y+3	; 0x03
    234a:	90 81       	ld	r25, Z
    234c:	80 91 0e 03 	lds	r24, 0x030E
    2350:	98 17       	cp	r25, r24
    2352:	71 f0       	breq	.+28     	; 0x2370 <xTaskCheckForTimeOut+0x46>
    2354:	ea 81       	ldd	r30, Y+2	; 0x02
    2356:	fb 81       	ldd	r31, Y+3	; 0x03
    2358:	21 81       	ldd	r18, Z+1	; 0x01
    235a:	32 81       	ldd	r19, Z+2	; 0x02
    235c:	80 91 06 03 	lds	r24, 0x0306
    2360:	90 91 07 03 	lds	r25, 0x0307
    2364:	82 17       	cp	r24, r18
    2366:	93 07       	cpc	r25, r19
    2368:	18 f0       	brcs	.+6      	; 0x2370 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    236a:	81 e0       	ldi	r24, 0x01	; 1
    236c:	89 83       	std	Y+1, r24	; 0x01
    236e:	2f c0       	rjmp	.+94     	; 0x23ce <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2370:	20 91 06 03 	lds	r18, 0x0306
    2374:	30 91 07 03 	lds	r19, 0x0307
    2378:	ea 81       	ldd	r30, Y+2	; 0x02
    237a:	fb 81       	ldd	r31, Y+3	; 0x03
    237c:	81 81       	ldd	r24, Z+1	; 0x01
    237e:	92 81       	ldd	r25, Z+2	; 0x02
    2380:	28 1b       	sub	r18, r24
    2382:	39 0b       	sbc	r19, r25
    2384:	ec 81       	ldd	r30, Y+4	; 0x04
    2386:	fd 81       	ldd	r31, Y+5	; 0x05
    2388:	80 81       	ld	r24, Z
    238a:	91 81       	ldd	r25, Z+1	; 0x01
    238c:	28 17       	cp	r18, r24
    238e:	39 07       	cpc	r19, r25
    2390:	e0 f4       	brcc	.+56     	; 0x23ca <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2392:	ec 81       	ldd	r30, Y+4	; 0x04
    2394:	fd 81       	ldd	r31, Y+5	; 0x05
    2396:	40 81       	ld	r20, Z
    2398:	51 81       	ldd	r21, Z+1	; 0x01
    239a:	ea 81       	ldd	r30, Y+2	; 0x02
    239c:	fb 81       	ldd	r31, Y+3	; 0x03
    239e:	21 81       	ldd	r18, Z+1	; 0x01
    23a0:	32 81       	ldd	r19, Z+2	; 0x02
    23a2:	80 91 06 03 	lds	r24, 0x0306
    23a6:	90 91 07 03 	lds	r25, 0x0307
    23aa:	b9 01       	movw	r22, r18
    23ac:	68 1b       	sub	r22, r24
    23ae:	79 0b       	sbc	r23, r25
    23b0:	cb 01       	movw	r24, r22
    23b2:	84 0f       	add	r24, r20
    23b4:	95 1f       	adc	r25, r21
    23b6:	ec 81       	ldd	r30, Y+4	; 0x04
    23b8:	fd 81       	ldd	r31, Y+5	; 0x05
    23ba:	91 83       	std	Z+1, r25	; 0x01
    23bc:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    23be:	8a 81       	ldd	r24, Y+2	; 0x02
    23c0:	9b 81       	ldd	r25, Y+3	; 0x03
    23c2:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    23c6:	19 82       	std	Y+1, r1	; 0x01
    23c8:	02 c0       	rjmp	.+4      	; 0x23ce <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    23ca:	81 e0       	ldi	r24, 0x01	; 1
    23cc:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    23ce:	0f 90       	pop	r0
    23d0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23d2:	89 81       	ldd	r24, Y+1	; 0x01
}
    23d4:	0f 90       	pop	r0
    23d6:	0f 90       	pop	r0
    23d8:	0f 90       	pop	r0
    23da:	0f 90       	pop	r0
    23dc:	0f 90       	pop	r0
    23de:	cf 91       	pop	r28
    23e0:	df 91       	pop	r29
    23e2:	08 95       	ret

000023e4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    23e4:	df 93       	push	r29
    23e6:	cf 93       	push	r28
    23e8:	cd b7       	in	r28, 0x3d	; 61
    23ea:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	80 93 0d 03 	sts	0x030D, r24
}
    23f2:	cf 91       	pop	r28
    23f4:	df 91       	pop	r29
    23f6:	08 95       	ret

000023f8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    23f8:	df 93       	push	r29
    23fa:	cf 93       	push	r28
    23fc:	00 d0       	rcall	.+0      	; 0x23fe <prvIdleTask+0x6>
    23fe:	cd b7       	in	r28, 0x3d	; 61
    2400:	de b7       	in	r29, 0x3e	; 62
    2402:	9a 83       	std	Y+2, r25	; 0x02
    2404:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2406:	0e 94 9a 12 	call	0x2534	; 0x2534 <prvCheckTasksWaitingTermination>
    240a:	fd cf       	rjmp	.-6      	; 0x2406 <prvIdleTask+0xe>

0000240c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    240c:	0f 93       	push	r16
    240e:	1f 93       	push	r17
    2410:	df 93       	push	r29
    2412:	cf 93       	push	r28
    2414:	cd b7       	in	r28, 0x3d	; 61
    2416:	de b7       	in	r29, 0x3e	; 62
    2418:	29 97       	sbiw	r28, 0x09	; 9
    241a:	0f b6       	in	r0, 0x3f	; 63
    241c:	f8 94       	cli
    241e:	de bf       	out	0x3e, r29	; 62
    2420:	0f be       	out	0x3f, r0	; 63
    2422:	cd bf       	out	0x3d, r28	; 61
    2424:	9a 83       	std	Y+2, r25	; 0x02
    2426:	89 83       	std	Y+1, r24	; 0x01
    2428:	7c 83       	std	Y+4, r23	; 0x04
    242a:	6b 83       	std	Y+3, r22	; 0x03
    242c:	4d 83       	std	Y+5, r20	; 0x05
    242e:	3f 83       	std	Y+7, r19	; 0x07
    2430:	2e 83       	std	Y+6, r18	; 0x06
    2432:	19 87       	std	Y+9, r17	; 0x09
    2434:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2436:	89 81       	ldd	r24, Y+1	; 0x01
    2438:	9a 81       	ldd	r25, Y+2	; 0x02
    243a:	49 96       	adiw	r24, 0x19	; 25
    243c:	2b 81       	ldd	r18, Y+3	; 0x03
    243e:	3c 81       	ldd	r19, Y+4	; 0x04
    2440:	b9 01       	movw	r22, r18
    2442:	48 e0       	ldi	r20, 0x08	; 8
    2444:	50 e0       	ldi	r21, 0x00	; 0
    2446:	0e 94 97 13 	call	0x272e	; 0x272e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    244a:	e9 81       	ldd	r30, Y+1	; 0x01
    244c:	fa 81       	ldd	r31, Y+2	; 0x02
    244e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2450:	8d 81       	ldd	r24, Y+5	; 0x05
    2452:	85 30       	cpi	r24, 0x05	; 5
    2454:	10 f0       	brcs	.+4      	; 0x245a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2456:	84 e0       	ldi	r24, 0x04	; 4
    2458:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    245a:	e9 81       	ldd	r30, Y+1	; 0x01
    245c:	fa 81       	ldd	r31, Y+2	; 0x02
    245e:	8d 81       	ldd	r24, Y+5	; 0x05
    2460:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2462:	89 81       	ldd	r24, Y+1	; 0x01
    2464:	9a 81       	ldd	r25, Y+2	; 0x02
    2466:	02 96       	adiw	r24, 0x02	; 2
    2468:	0e 94 38 04 	call	0x870	; 0x870 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    246c:	89 81       	ldd	r24, Y+1	; 0x01
    246e:	9a 81       	ldd	r25, Y+2	; 0x02
    2470:	0c 96       	adiw	r24, 0x0c	; 12
    2472:	0e 94 38 04 	call	0x870	; 0x870 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2476:	e9 81       	ldd	r30, Y+1	; 0x01
    2478:	fa 81       	ldd	r31, Y+2	; 0x02
    247a:	89 81       	ldd	r24, Y+1	; 0x01
    247c:	9a 81       	ldd	r25, Y+2	; 0x02
    247e:	91 87       	std	Z+9, r25	; 0x09
    2480:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2482:	8d 81       	ldd	r24, Y+5	; 0x05
    2484:	28 2f       	mov	r18, r24
    2486:	30 e0       	ldi	r19, 0x00	; 0
    2488:	85 e0       	ldi	r24, 0x05	; 5
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	82 1b       	sub	r24, r18
    248e:	93 0b       	sbc	r25, r19
    2490:	e9 81       	ldd	r30, Y+1	; 0x01
    2492:	fa 81       	ldd	r31, Y+2	; 0x02
    2494:	95 87       	std	Z+13, r25	; 0x0d
    2496:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2498:	e9 81       	ldd	r30, Y+1	; 0x01
    249a:	fa 81       	ldd	r31, Y+2	; 0x02
    249c:	89 81       	ldd	r24, Y+1	; 0x01
    249e:	9a 81       	ldd	r25, Y+2	; 0x02
    24a0:	93 8b       	std	Z+19, r25	; 0x13
    24a2:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    24a4:	29 96       	adiw	r28, 0x09	; 9
    24a6:	0f b6       	in	r0, 0x3f	; 63
    24a8:	f8 94       	cli
    24aa:	de bf       	out	0x3e, r29	; 62
    24ac:	0f be       	out	0x3f, r0	; 63
    24ae:	cd bf       	out	0x3d, r28	; 61
    24b0:	cf 91       	pop	r28
    24b2:	df 91       	pop	r29
    24b4:	1f 91       	pop	r17
    24b6:	0f 91       	pop	r16
    24b8:	08 95       	ret

000024ba <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    24ba:	df 93       	push	r29
    24bc:	cf 93       	push	r28
    24be:	0f 92       	push	r0
    24c0:	cd b7       	in	r28, 0x3d	; 61
    24c2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    24c4:	19 82       	std	Y+1, r1	; 0x01
    24c6:	13 c0       	rjmp	.+38     	; 0x24ee <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    24c8:	89 81       	ldd	r24, Y+1	; 0x01
    24ca:	28 2f       	mov	r18, r24
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	c9 01       	movw	r24, r18
    24d0:	88 0f       	add	r24, r24
    24d2:	99 1f       	adc	r25, r25
    24d4:	88 0f       	add	r24, r24
    24d6:	99 1f       	adc	r25, r25
    24d8:	88 0f       	add	r24, r24
    24da:	99 1f       	adc	r25, r25
    24dc:	82 0f       	add	r24, r18
    24de:	93 1f       	adc	r25, r19
    24e0:	80 5f       	subi	r24, 0xF0	; 240
    24e2:	9c 4f       	sbci	r25, 0xFC	; 252
    24e4:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    24e8:	89 81       	ldd	r24, Y+1	; 0x01
    24ea:	8f 5f       	subi	r24, 0xFF	; 255
    24ec:	89 83       	std	Y+1, r24	; 0x01
    24ee:	89 81       	ldd	r24, Y+1	; 0x01
    24f0:	85 30       	cpi	r24, 0x05	; 5
    24f2:	50 f3       	brcs	.-44     	; 0x24c8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    24f4:	8d e3       	ldi	r24, 0x3D	; 61
    24f6:	93 e0       	ldi	r25, 0x03	; 3
    24f8:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    24fc:	86 e4       	ldi	r24, 0x46	; 70
    24fe:	93 e0       	ldi	r25, 0x03	; 3
    2500:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2504:	83 e5       	ldi	r24, 0x53	; 83
    2506:	93 e0       	ldi	r25, 0x03	; 3
    2508:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    250c:	8c e5       	ldi	r24, 0x5C	; 92
    250e:	93 e0       	ldi	r25, 0x03	; 3
    2510:	0e 94 0e 04 	call	0x81c	; 0x81c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2514:	8d e3       	ldi	r24, 0x3D	; 61
    2516:	93 e0       	ldi	r25, 0x03	; 3
    2518:	90 93 50 03 	sts	0x0350, r25
    251c:	80 93 4f 03 	sts	0x034F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2520:	86 e4       	ldi	r24, 0x46	; 70
    2522:	93 e0       	ldi	r25, 0x03	; 3
    2524:	90 93 52 03 	sts	0x0352, r25
    2528:	80 93 51 03 	sts	0x0351, r24
}
    252c:	0f 90       	pop	r0
    252e:	cf 91       	pop	r28
    2530:	df 91       	pop	r29
    2532:	08 95       	ret

00002534 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2534:	df 93       	push	r29
    2536:	cf 93       	push	r28
    2538:	00 d0       	rcall	.+0      	; 0x253a <prvCheckTasksWaitingTermination+0x6>
    253a:	0f 92       	push	r0
    253c:	cd b7       	in	r28, 0x3d	; 61
    253e:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2540:	80 91 04 03 	lds	r24, 0x0304
    2544:	88 23       	and	r24, r24
    2546:	71 f1       	breq	.+92     	; 0x25a4 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2548:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    254c:	80 91 5c 03 	lds	r24, 0x035C
    2550:	1b 82       	std	Y+3, r1	; 0x03
    2552:	88 23       	and	r24, r24
    2554:	11 f4       	brne	.+4      	; 0x255a <prvCheckTasksWaitingTermination+0x26>
    2556:	81 e0       	ldi	r24, 0x01	; 1
    2558:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    255a:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    255e:	8b 81       	ldd	r24, Y+3	; 0x03
    2560:	88 23       	and	r24, r24
    2562:	01 f5       	brne	.+64     	; 0x25a4 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2564:	0f b6       	in	r0, 0x3f	; 63
    2566:	f8 94       	cli
    2568:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    256a:	e0 91 61 03 	lds	r30, 0x0361
    256e:	f0 91 62 03 	lds	r31, 0x0362
    2572:	86 81       	ldd	r24, Z+6	; 0x06
    2574:	97 81       	ldd	r25, Z+7	; 0x07
    2576:	9a 83       	std	Y+2, r25	; 0x02
    2578:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    257a:	89 81       	ldd	r24, Y+1	; 0x01
    257c:	9a 81       	ldd	r25, Y+2	; 0x02
    257e:	02 96       	adiw	r24, 0x02	; 2
    2580:	0e 94 00 05 	call	0xa00	; 0xa00 <vListRemove>
					--uxCurrentNumberOfTasks;
    2584:	80 91 05 03 	lds	r24, 0x0305
    2588:	81 50       	subi	r24, 0x01	; 1
    258a:	80 93 05 03 	sts	0x0305, r24
					--uxTasksDeleted;
    258e:	80 91 04 03 	lds	r24, 0x0304
    2592:	81 50       	subi	r24, 0x01	; 1
    2594:	80 93 04 03 	sts	0x0304, r24
				}
				taskEXIT_CRITICAL();
    2598:	0f 90       	pop	r0
    259a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    259c:	89 81       	ldd	r24, Y+1	; 0x01
    259e:	9a 81       	ldd	r25, Y+2	; 0x02
    25a0:	0e 94 71 13 	call	0x26e2	; 0x26e2 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    25a4:	0f 90       	pop	r0
    25a6:	0f 90       	pop	r0
    25a8:	0f 90       	pop	r0
    25aa:	cf 91       	pop	r28
    25ac:	df 91       	pop	r29
    25ae:	08 95       	ret

000025b0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    25b0:	df 93       	push	r29
    25b2:	cf 93       	push	r28
    25b4:	00 d0       	rcall	.+0      	; 0x25b6 <prvAddCurrentTaskToDelayedList+0x6>
    25b6:	cd b7       	in	r28, 0x3d	; 61
    25b8:	de b7       	in	r29, 0x3e	; 62
    25ba:	9a 83       	std	Y+2, r25	; 0x02
    25bc:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    25be:	e0 91 02 03 	lds	r30, 0x0302
    25c2:	f0 91 03 03 	lds	r31, 0x0303
    25c6:	89 81       	ldd	r24, Y+1	; 0x01
    25c8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ca:	93 83       	std	Z+3, r25	; 0x03
    25cc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    25ce:	20 91 06 03 	lds	r18, 0x0306
    25d2:	30 91 07 03 	lds	r19, 0x0307
    25d6:	89 81       	ldd	r24, Y+1	; 0x01
    25d8:	9a 81       	ldd	r25, Y+2	; 0x02
    25da:	82 17       	cp	r24, r18
    25dc:	93 07       	cpc	r25, r19
    25de:	70 f4       	brcc	.+28     	; 0x25fc <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25e0:	80 91 51 03 	lds	r24, 0x0351
    25e4:	90 91 52 03 	lds	r25, 0x0352
    25e8:	20 91 02 03 	lds	r18, 0x0302
    25ec:	30 91 03 03 	lds	r19, 0x0303
    25f0:	2e 5f       	subi	r18, 0xFE	; 254
    25f2:	3f 4f       	sbci	r19, 0xFF	; 255
    25f4:	b9 01       	movw	r22, r18
    25f6:	0e 94 94 04 	call	0x928	; 0x928 <vListInsert>
    25fa:	1e c0       	rjmp	.+60     	; 0x2638 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25fc:	40 91 4f 03 	lds	r20, 0x034F
    2600:	50 91 50 03 	lds	r21, 0x0350
    2604:	80 91 02 03 	lds	r24, 0x0302
    2608:	90 91 03 03 	lds	r25, 0x0303
    260c:	9c 01       	movw	r18, r24
    260e:	2e 5f       	subi	r18, 0xFE	; 254
    2610:	3f 4f       	sbci	r19, 0xFF	; 255
    2612:	ca 01       	movw	r24, r20
    2614:	b9 01       	movw	r22, r18
    2616:	0e 94 94 04 	call	0x928	; 0x928 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    261a:	20 91 6b 00 	lds	r18, 0x006B
    261e:	30 91 6c 00 	lds	r19, 0x006C
    2622:	89 81       	ldd	r24, Y+1	; 0x01
    2624:	9a 81       	ldd	r25, Y+2	; 0x02
    2626:	82 17       	cp	r24, r18
    2628:	93 07       	cpc	r25, r19
    262a:	30 f4       	brcc	.+12     	; 0x2638 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    262c:	89 81       	ldd	r24, Y+1	; 0x01
    262e:	9a 81       	ldd	r25, Y+2	; 0x02
    2630:	90 93 6c 00 	sts	0x006C, r25
    2634:	80 93 6b 00 	sts	0x006B, r24
		}
	}
}
    2638:	0f 90       	pop	r0
    263a:	0f 90       	pop	r0
    263c:	cf 91       	pop	r28
    263e:	df 91       	pop	r29
    2640:	08 95       	ret

00002642 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2642:	df 93       	push	r29
    2644:	cf 93       	push	r28
    2646:	cd b7       	in	r28, 0x3d	; 61
    2648:	de b7       	in	r29, 0x3e	; 62
    264a:	28 97       	sbiw	r28, 0x08	; 8
    264c:	0f b6       	in	r0, 0x3f	; 63
    264e:	f8 94       	cli
    2650:	de bf       	out	0x3e, r29	; 62
    2652:	0f be       	out	0x3f, r0	; 63
    2654:	cd bf       	out	0x3d, r28	; 61
    2656:	9c 83       	std	Y+4, r25	; 0x04
    2658:	8b 83       	std	Y+3, r24	; 0x03
    265a:	7e 83       	std	Y+6, r23	; 0x06
    265c:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    265e:	81 e2       	ldi	r24, 0x21	; 33
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	0e 94 a2 03 	call	0x744	; 0x744 <pvPortMalloc>
    2666:	9a 83       	std	Y+2, r25	; 0x02
    2668:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    266a:	89 81       	ldd	r24, Y+1	; 0x01
    266c:	9a 81       	ldd	r25, Y+2	; 0x02
    266e:	00 97       	sbiw	r24, 0x00	; 0
    2670:	69 f1       	breq	.+90     	; 0x26cc <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2672:	8d 81       	ldd	r24, Y+5	; 0x05
    2674:	9e 81       	ldd	r25, Y+6	; 0x06
    2676:	00 97       	sbiw	r24, 0x00	; 0
    2678:	39 f4       	brne	.+14     	; 0x2688 <prvAllocateTCBAndStack+0x46>
    267a:	8b 81       	ldd	r24, Y+3	; 0x03
    267c:	9c 81       	ldd	r25, Y+4	; 0x04
    267e:	0e 94 a2 03 	call	0x744	; 0x744 <pvPortMalloc>
    2682:	98 87       	std	Y+8, r25	; 0x08
    2684:	8f 83       	std	Y+7, r24	; 0x07
    2686:	04 c0       	rjmp	.+8      	; 0x2690 <prvAllocateTCBAndStack+0x4e>
    2688:	8d 81       	ldd	r24, Y+5	; 0x05
    268a:	9e 81       	ldd	r25, Y+6	; 0x06
    268c:	98 87       	std	Y+8, r25	; 0x08
    268e:	8f 83       	std	Y+7, r24	; 0x07
    2690:	e9 81       	ldd	r30, Y+1	; 0x01
    2692:	fa 81       	ldd	r31, Y+2	; 0x02
    2694:	8f 81       	ldd	r24, Y+7	; 0x07
    2696:	98 85       	ldd	r25, Y+8	; 0x08
    2698:	90 8f       	std	Z+24, r25	; 0x18
    269a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    269c:	e9 81       	ldd	r30, Y+1	; 0x01
    269e:	fa 81       	ldd	r31, Y+2	; 0x02
    26a0:	87 89       	ldd	r24, Z+23	; 0x17
    26a2:	90 8d       	ldd	r25, Z+24	; 0x18
    26a4:	00 97       	sbiw	r24, 0x00	; 0
    26a6:	39 f4       	brne	.+14     	; 0x26b6 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	9a 81       	ldd	r25, Y+2	; 0x02
    26ac:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vPortFree>
			pxNewTCB = NULL;
    26b0:	1a 82       	std	Y+2, r1	; 0x02
    26b2:	19 82       	std	Y+1, r1	; 0x01
    26b4:	0b c0       	rjmp	.+22     	; 0x26cc <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    26b6:	e9 81       	ldd	r30, Y+1	; 0x01
    26b8:	fa 81       	ldd	r31, Y+2	; 0x02
    26ba:	87 89       	ldd	r24, Z+23	; 0x17
    26bc:	90 8d       	ldd	r25, Z+24	; 0x18
    26be:	2b 81       	ldd	r18, Y+3	; 0x03
    26c0:	3c 81       	ldd	r19, Y+4	; 0x04
    26c2:	65 ea       	ldi	r22, 0xA5	; 165
    26c4:	70 e0       	ldi	r23, 0x00	; 0
    26c6:	a9 01       	movw	r20, r18
    26c8:	0e 94 90 13 	call	0x2720	; 0x2720 <memset>
		}
	}

	return pxNewTCB;
    26cc:	89 81       	ldd	r24, Y+1	; 0x01
    26ce:	9a 81       	ldd	r25, Y+2	; 0x02
}
    26d0:	28 96       	adiw	r28, 0x08	; 8
    26d2:	0f b6       	in	r0, 0x3f	; 63
    26d4:	f8 94       	cli
    26d6:	de bf       	out	0x3e, r29	; 62
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	cd bf       	out	0x3d, r28	; 61
    26dc:	cf 91       	pop	r28
    26de:	df 91       	pop	r29
    26e0:	08 95       	ret

000026e2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    26e2:	df 93       	push	r29
    26e4:	cf 93       	push	r28
    26e6:	00 d0       	rcall	.+0      	; 0x26e8 <prvDeleteTCB+0x6>
    26e8:	cd b7       	in	r28, 0x3d	; 61
    26ea:	de b7       	in	r29, 0x3e	; 62
    26ec:	9a 83       	std	Y+2, r25	; 0x02
    26ee:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    26f0:	e9 81       	ldd	r30, Y+1	; 0x01
    26f2:	fa 81       	ldd	r31, Y+2	; 0x02
    26f4:	87 89       	ldd	r24, Z+23	; 0x17
    26f6:	90 8d       	ldd	r25, Z+24	; 0x18
    26f8:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vPortFree>
		vPortFree( pxTCB );
    26fc:	89 81       	ldd	r24, Y+1	; 0x01
    26fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2700:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vPortFree>
	}
    2704:	0f 90       	pop	r0
    2706:	0f 90       	pop	r0
    2708:	cf 91       	pop	r28
    270a:	df 91       	pop	r29
    270c:	08 95       	ret

0000270e <memcpy>:
    270e:	fb 01       	movw	r30, r22
    2710:	dc 01       	movw	r26, r24
    2712:	02 c0       	rjmp	.+4      	; 0x2718 <memcpy+0xa>
    2714:	01 90       	ld	r0, Z+
    2716:	0d 92       	st	X+, r0
    2718:	41 50       	subi	r20, 0x01	; 1
    271a:	50 40       	sbci	r21, 0x00	; 0
    271c:	d8 f7       	brcc	.-10     	; 0x2714 <memcpy+0x6>
    271e:	08 95       	ret

00002720 <memset>:
    2720:	dc 01       	movw	r26, r24
    2722:	01 c0       	rjmp	.+2      	; 0x2726 <memset+0x6>
    2724:	6d 93       	st	X+, r22
    2726:	41 50       	subi	r20, 0x01	; 1
    2728:	50 40       	sbci	r21, 0x00	; 0
    272a:	e0 f7       	brcc	.-8      	; 0x2724 <memset+0x4>
    272c:	08 95       	ret

0000272e <strncpy>:
    272e:	fb 01       	movw	r30, r22
    2730:	dc 01       	movw	r26, r24
    2732:	41 50       	subi	r20, 0x01	; 1
    2734:	50 40       	sbci	r21, 0x00	; 0
    2736:	48 f0       	brcs	.+18     	; 0x274a <strncpy+0x1c>
    2738:	01 90       	ld	r0, Z+
    273a:	0d 92       	st	X+, r0
    273c:	00 20       	and	r0, r0
    273e:	c9 f7       	brne	.-14     	; 0x2732 <strncpy+0x4>
    2740:	01 c0       	rjmp	.+2      	; 0x2744 <strncpy+0x16>
    2742:	1d 92       	st	X+, r1
    2744:	41 50       	subi	r20, 0x01	; 1
    2746:	50 40       	sbci	r21, 0x00	; 0
    2748:	e0 f7       	brcc	.-8      	; 0x2742 <strncpy+0x14>
    274a:	08 95       	ret

0000274c <_exit>:
    274c:	f8 94       	cli

0000274e <__stop_program>:
    274e:	ff cf       	rjmp	.-2      	; 0x274e <__stop_program>
